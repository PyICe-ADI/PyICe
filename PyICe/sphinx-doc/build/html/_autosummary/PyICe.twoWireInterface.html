<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>PyICe.twoWireInterface &mdash; PyICe 9000 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '9000',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/tssop.ico"/>
    <link rel="top" title="PyICe 9000 documentation" href="../PyICe.html" />
    <link rel="next" title="PyICe.spi_instrument" href="PyICe.spi_instrument.html" />
    <link rel="prev" title="PyICe.twi_instrument" href="PyICe.twi_instrument.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-PyICe.twoWireInterface">
<span id="pyice-twowireinterface"></span><h1>PyICe.twoWireInterface<a class="headerlink" href="#module-PyICe.twoWireInterface" title="Permalink to this headline">¶</a></h1>
<div class="section" id="smbus-interface-hardware-drivers">
<h2>SMBus Interface Hardware Drivers<a class="headerlink" href="#smbus-interface-hardware-drivers" title="Permalink to this headline">¶</a></h2>
<p class="rubric">Classes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#PyICe.twoWireInterface.i2c_buspirate" title="PyICe.twoWireInterface.i2c_buspirate"><code class="xref py py-obj docutils literal"><span class="pre">i2c_buspirate</span></code></a>(interface_raw_serial)</td>
<td>dangerous prototypes bus pirate communication board</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#PyICe.twoWireInterface.i2c_dc590" title="PyICe.twoWireInterface.i2c_dc590"><code class="xref py py-obj docutils literal"><span class="pre">i2c_dc590</span></code></a>(interface_stream)</td>
<td>Generic DC590/Linduino Driver.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#PyICe.twoWireInterface.i2c_dc590_list_read" title="PyICe.twoWireInterface.i2c_dc590_list_read"><code class="xref py py-obj docutils literal"><span class="pre">i2c_dc590_list_read</span></code></a>(interface_stream)</td>
<td>use with Steve M&#8217;s linduino sketch extension DC590ListRead implementing ganged register reads</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#PyICe.twoWireInterface.i2c_dummy" title="PyICe.twoWireInterface.i2c_dummy"><code class="xref py py-obj docutils literal"><span class="pre">i2c_dummy</span></code></a>([delay])</td>
<td>dummy interface for testing without any hardware.  No actual communication occurs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#PyICe.twoWireInterface.i2c_kernel" title="PyICe.twoWireInterface.i2c_kernel"><code class="xref py py-obj docutils literal"><span class="pre">i2c_kernel</span></code></a>(bus_number)</td>
<td>communication class using Linux kernel driver</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#PyICe.twoWireInterface.i2c_pic" title="PyICe.twoWireInterface.i2c_pic"><code class="xref py py-obj docutils literal"><span class="pre">i2c_pic</span></code></a>(interface_raw_serial)</td>
<td>communication class to simplify talking to dave&#8217;s external i2c interface firmware on George&#8217;s development board (pic18F4553 and similar)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#PyICe.twoWireInterface.i2c_scpi" title="PyICe.twoWireInterface.i2c_scpi"><code class="xref py py-obj docutils literal"><span class="pre">i2c_scpi</span></code></a>(visa_interface)</td>
<td>communication class to simplify talking to atmega32u4 with Steve/Eric SCPI firmware</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#PyICe.twoWireInterface.i2c_scpi_sp" title="PyICe.twoWireInterface.i2c_scpi_sp"><code class="xref py py-obj docutils literal"><span class="pre">i2c_scpi_sp</span></code></a>(visa_interface,&nbsp;portnum,&nbsp;sclpin,&nbsp;...)</td>
<td>communication class to simplify talking to atmega32u4 softport with Steve/Eric SCPI firmware</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">i2c_scpi_testhook</span></code>(serial_port)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#PyICe.twoWireInterface.twoWireInterface" title="PyICe.twoWireInterface.twoWireInterface"><code class="xref py py-obj docutils literal"><span class="pre">twoWireInterface</span></code></a></td>
<td>this is the master i2c class, all other i2c adapters inherit from this</td>
</tr>
</tbody>
</table>
<p class="rubric">Exceptions</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#PyICe.twoWireInterface.i2cAcknowledgeError" title="PyICe.twoWireInterface.i2cAcknowledgeError"><code class="xref py py-obj docutils literal"><span class="pre">i2cAcknowledgeError</span></code></a>([value])</td>
<td>Got expected responses from I2C master device, but slave devices not acknowledging address or subsequent data bytes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#PyICe.twoWireInterface.i2cAddressAcknowledgeError" title="PyICe.twoWireInterface.i2cAddressAcknowledgeError"><code class="xref py py-obj docutils literal"><span class="pre">i2cAddressAcknowledgeError</span></code></a>([value])</td>
<td>Got expected responses from I2C master device, but slave device not acknowledging address.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#PyICe.twoWireInterface.i2cCommandCodeAcknowledgeError" title="PyICe.twoWireInterface.i2cCommandCodeAcknowledgeError"><code class="xref py py-obj docutils literal"><span class="pre">i2cCommandCodeAcknowledgeError</span></code></a>([value])</td>
<td>Got expected responses from I2C master device, but slave device not acknowledging command code.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#PyICe.twoWireInterface.i2cDataAcknowledgeError" title="PyICe.twoWireInterface.i2cDataAcknowledgeError"><code class="xref py py-obj docutils literal"><span class="pre">i2cDataAcknowledgeError</span></code></a>([value])</td>
<td>Got expected responses from I2C master device and slave address, but slave devices not acknowledging subsequent data bytes.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#PyICe.twoWireInterface.i2cDataHighAcknowledgeError" title="PyICe.twoWireInterface.i2cDataHighAcknowledgeError"><code class="xref py py-obj docutils literal"><span class="pre">i2cDataHighAcknowledgeError</span></code></a>([value])</td>
<td>Got expected responses from I2C master device and slave address, but slave devices not acknowledging high data byte.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#PyICe.twoWireInterface.i2cDataLowAcknowledgeError" title="PyICe.twoWireInterface.i2cDataLowAcknowledgeError"><code class="xref py py-obj docutils literal"><span class="pre">i2cDataLowAcknowledgeError</span></code></a>([value])</td>
<td>Got expected responses from I2C master device and slave address, but slave devices not acknowledging low data byte.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#PyICe.twoWireInterface.i2cDataPECAcknowledgeError" title="PyICe.twoWireInterface.i2cDataPECAcknowledgeError"><code class="xref py py-obj docutils literal"><span class="pre">i2cDataPECAcknowledgeError</span></code></a>([value])</td>
<td>Got expected responses from I2C master device and slave address, but slave devices not acknowledging PEC data byte.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#PyICe.twoWireInterface.i2cError" title="PyICe.twoWireInterface.i2cError"><code class="xref py py-obj docutils literal"><span class="pre">i2cError</span></code></a>([value])</td>
<td>I2C Error Superclass - Don&#8217;t raise this exception.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#PyICe.twoWireInterface.i2cIOError" title="PyICe.twoWireInterface.i2cIOError"><code class="xref py py-obj docutils literal"><span class="pre">i2cIOError</span></code></a>([value])</td>
<td>I2C Bus communication failure, not otherwise specified.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#PyICe.twoWireInterface.i2cMasterError" title="PyICe.twoWireInterface.i2cMasterError"><code class="xref py py-obj docutils literal"><span class="pre">i2cMasterError</span></code></a>([value])</td>
<td>Unexpected response from I2C interface device, possibly caused by dropped USB packets, serial error, unpowered master, or other &#8216;computer&#8217; problems.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#PyICe.twoWireInterface.i2cPECError" title="PyICe.twoWireInterface.i2cPECError"><code class="xref py py-obj docutils literal"><span class="pre">i2cPECError</span></code></a>([value])</td>
<td>Got expected responses from I2C master and slave acknowledging all bytes, but failed to reconcile SMBus packet error check.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#PyICe.twoWireInterface.i2cReadAddressAcknowledgeError" title="PyICe.twoWireInterface.i2cReadAddressAcknowledgeError"><code class="xref py py-obj docutils literal"><span class="pre">i2cReadAddressAcknowledgeError</span></code></a>([value])</td>
<td>Got expected responses from I2C master device, but slave device not acknowledging read address.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#PyICe.twoWireInterface.i2cStartStopError" title="PyICe.twoWireInterface.i2cStartStopError"><code class="xref py py-obj docutils literal"><span class="pre">i2cStartStopError</span></code></a>([value])</td>
<td>Failed to assert Start of Stop signals - not supported by all hardware</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#PyICe.twoWireInterface.i2cUnimplementedError" title="PyICe.twoWireInterface.i2cUnimplementedError"><code class="xref py py-obj docutils literal"><span class="pre">i2cUnimplementedError</span></code></a>([value])</td>
<td>Feature currently unimplemented.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#PyICe.twoWireInterface.i2cWriteAddressAcknowledgeError" title="PyICe.twoWireInterface.i2cWriteAddressAcknowledgeError"><code class="xref py py-obj docutils literal"><span class="pre">i2cWriteAddressAcknowledgeError</span></code></a>([value])</td>
<td>Got expected responses from I2C master device, but slave device not acknowledging write address.</td>
</tr>
</tbody>
</table>
<dl class="exception">
<dt id="PyICe.twoWireInterface.i2cAcknowledgeError">
<em class="property">exception </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">i2cAcknowledgeError</code><span class="sig-paren">(</span><em>value=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2cAcknowledgeError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2cAcknowledgeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#PyICe.twoWireInterface.i2cError" title="PyICe.twoWireInterface.i2cError"><code class="xref py py-class docutils literal"><span class="pre">PyICe.twoWireInterface.i2cError</span></code></a></p>
<p>Got expected responses from I2C master device, but slave devices not acknowledging address or subsequent data bytes.</p>
</dd></dl>

<dl class="exception">
<dt id="PyICe.twoWireInterface.i2cAddressAcknowledgeError">
<em class="property">exception </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">i2cAddressAcknowledgeError</code><span class="sig-paren">(</span><em>value=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2cAddressAcknowledgeError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2cAddressAcknowledgeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#PyICe.twoWireInterface.i2cAcknowledgeError" title="PyICe.twoWireInterface.i2cAcknowledgeError"><code class="xref py py-class docutils literal"><span class="pre">PyICe.twoWireInterface.i2cAcknowledgeError</span></code></a></p>
<p>Got expected responses from I2C master device, but slave device not acknowledging address.</p>
</dd></dl>

<dl class="exception">
<dt id="PyICe.twoWireInterface.i2cCommandCodeAcknowledgeError">
<em class="property">exception </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">i2cCommandCodeAcknowledgeError</code><span class="sig-paren">(</span><em>value=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2cCommandCodeAcknowledgeError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2cCommandCodeAcknowledgeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#PyICe.twoWireInterface.i2cAcknowledgeError" title="PyICe.twoWireInterface.i2cAcknowledgeError"><code class="xref py py-class docutils literal"><span class="pre">PyICe.twoWireInterface.i2cAcknowledgeError</span></code></a></p>
<p>Got expected responses from I2C master device, but slave device not acknowledging command code.</p>
</dd></dl>

<dl class="exception">
<dt id="PyICe.twoWireInterface.i2cDataAcknowledgeError">
<em class="property">exception </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">i2cDataAcknowledgeError</code><span class="sig-paren">(</span><em>value=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2cDataAcknowledgeError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2cDataAcknowledgeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#PyICe.twoWireInterface.i2cAcknowledgeError" title="PyICe.twoWireInterface.i2cAcknowledgeError"><code class="xref py py-class docutils literal"><span class="pre">PyICe.twoWireInterface.i2cAcknowledgeError</span></code></a></p>
<p>Got expected responses from I2C master device and slave address, but slave devices not acknowledging subsequent data bytes.</p>
</dd></dl>

<dl class="exception">
<dt id="PyICe.twoWireInterface.i2cDataHighAcknowledgeError">
<em class="property">exception </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">i2cDataHighAcknowledgeError</code><span class="sig-paren">(</span><em>value=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2cDataHighAcknowledgeError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2cDataHighAcknowledgeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#PyICe.twoWireInterface.i2cDataAcknowledgeError" title="PyICe.twoWireInterface.i2cDataAcknowledgeError"><code class="xref py py-class docutils literal"><span class="pre">PyICe.twoWireInterface.i2cDataAcknowledgeError</span></code></a></p>
<p>Got expected responses from I2C master device and slave address, but slave devices not acknowledging high data byte.</p>
</dd></dl>

<dl class="exception">
<dt id="PyICe.twoWireInterface.i2cDataLowAcknowledgeError">
<em class="property">exception </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">i2cDataLowAcknowledgeError</code><span class="sig-paren">(</span><em>value=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2cDataLowAcknowledgeError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2cDataLowAcknowledgeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#PyICe.twoWireInterface.i2cDataAcknowledgeError" title="PyICe.twoWireInterface.i2cDataAcknowledgeError"><code class="xref py py-class docutils literal"><span class="pre">PyICe.twoWireInterface.i2cDataAcknowledgeError</span></code></a></p>
<p>Got expected responses from I2C master device and slave address, but slave devices not acknowledging low data byte.</p>
</dd></dl>

<dl class="exception">
<dt id="PyICe.twoWireInterface.i2cDataPECAcknowledgeError">
<em class="property">exception </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">i2cDataPECAcknowledgeError</code><span class="sig-paren">(</span><em>value=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2cDataPECAcknowledgeError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2cDataPECAcknowledgeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#PyICe.twoWireInterface.i2cDataAcknowledgeError" title="PyICe.twoWireInterface.i2cDataAcknowledgeError"><code class="xref py py-class docutils literal"><span class="pre">PyICe.twoWireInterface.i2cDataAcknowledgeError</span></code></a></p>
<p>Got expected responses from I2C master device and slave address, but slave devices not acknowledging PEC data byte.</p>
</dd></dl>

<dl class="exception">
<dt id="PyICe.twoWireInterface.i2cError">
<em class="property">exception </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">i2cError</code><span class="sig-paren">(</span><em>value=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2cError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2cError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>I2C Error Superclass - Don&#8217;t raise this exception.  Use more specific subclass.</p>
</dd></dl>

<dl class="exception">
<dt id="PyICe.twoWireInterface.i2cIOError">
<em class="property">exception </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">i2cIOError</code><span class="sig-paren">(</span><em>value=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2cIOError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2cIOError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#PyICe.twoWireInterface.i2cError" title="PyICe.twoWireInterface.i2cError"><code class="xref py py-class docutils literal"><span class="pre">PyICe.twoWireInterface.i2cError</span></code></a></p>
<p>I2C Bus communication failure, not otherwise specified.</p>
</dd></dl>

<dl class="exception">
<dt id="PyICe.twoWireInterface.i2cMasterError">
<em class="property">exception </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">i2cMasterError</code><span class="sig-paren">(</span><em>value=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2cMasterError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2cMasterError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#PyICe.twoWireInterface.i2cError" title="PyICe.twoWireInterface.i2cError"><code class="xref py py-class docutils literal"><span class="pre">PyICe.twoWireInterface.i2cError</span></code></a></p>
<p>Unexpected response from I2C interface device,
possibly caused by dropped USB packets, serial error,
unpowered master, or other &#8216;computer&#8217; problems.
Excludes communication problems with a device on the two-wire bus.</p>
</dd></dl>

<dl class="exception">
<dt id="PyICe.twoWireInterface.i2cPECError">
<em class="property">exception </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">i2cPECError</code><span class="sig-paren">(</span><em>value=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2cPECError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2cPECError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#PyICe.twoWireInterface.i2cError" title="PyICe.twoWireInterface.i2cError"><code class="xref py py-class docutils literal"><span class="pre">PyICe.twoWireInterface.i2cError</span></code></a></p>
<p>Got expected responses from I2C master and slave acknowledging all bytes, but failed to reconcile SMBus packet error check.</p>
</dd></dl>

<dl class="exception">
<dt id="PyICe.twoWireInterface.i2cReadAddressAcknowledgeError">
<em class="property">exception </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">i2cReadAddressAcknowledgeError</code><span class="sig-paren">(</span><em>value=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2cReadAddressAcknowledgeError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2cReadAddressAcknowledgeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#PyICe.twoWireInterface.i2cAddressAcknowledgeError" title="PyICe.twoWireInterface.i2cAddressAcknowledgeError"><code class="xref py py-class docutils literal"><span class="pre">PyICe.twoWireInterface.i2cAddressAcknowledgeError</span></code></a></p>
<p>Got expected responses from I2C master device, but slave device not acknowledging read address.</p>
</dd></dl>

<dl class="exception">
<dt id="PyICe.twoWireInterface.i2cStartStopError">
<em class="property">exception </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">i2cStartStopError</code><span class="sig-paren">(</span><em>value=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2cStartStopError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2cStartStopError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#PyICe.twoWireInterface.i2cError" title="PyICe.twoWireInterface.i2cError"><code class="xref py py-class docutils literal"><span class="pre">PyICe.twoWireInterface.i2cError</span></code></a></p>
<p>Failed to assert Start of Stop signals - not supported by all hardware</p>
</dd></dl>

<dl class="exception">
<dt id="PyICe.twoWireInterface.i2cUnimplementedError">
<em class="property">exception </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">i2cUnimplementedError</code><span class="sig-paren">(</span><em>value=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2cUnimplementedError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2cUnimplementedError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#PyICe.twoWireInterface.i2cError" title="PyICe.twoWireInterface.i2cError"><code class="xref py py-class docutils literal"><span class="pre">PyICe.twoWireInterface.i2cError</span></code></a>, <code class="xref py py-class docutils literal"><span class="pre">exceptions.NotImplementedError</span></code></p>
<p>Feature currently unimplemented.  Write it if you want it!</p>
</dd></dl>

<dl class="exception">
<dt id="PyICe.twoWireInterface.i2cWriteAddressAcknowledgeError">
<em class="property">exception </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">i2cWriteAddressAcknowledgeError</code><span class="sig-paren">(</span><em>value=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2cWriteAddressAcknowledgeError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2cWriteAddressAcknowledgeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#PyICe.twoWireInterface.i2cAddressAcknowledgeError" title="PyICe.twoWireInterface.i2cAddressAcknowledgeError"><code class="xref py py-class docutils literal"><span class="pre">PyICe.twoWireInterface.i2cAddressAcknowledgeError</span></code></a></p>
<p>Got expected responses from I2C master device, but slave device not acknowledging write address.</p>
</dd></dl>

<dl class="class">
<dt id="PyICe.twoWireInterface.i2c_buspirate">
<em class="property">class </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">i2c_buspirate</code><span class="sig-paren">(</span><em>interface_raw_serial</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_buspirate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#PyICe.twoWireInterface.twoWireInterface" title="PyICe.twoWireInterface.twoWireInterface"><code class="xref py py-class docutils literal"><span class="pre">PyICe.twoWireInterface.twoWireInterface</span></code></a></p>
<p>dangerous prototypes bus pirate communication board</p>
<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.alert_response">
<code class="descname">alert_response</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.alert_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Another optional signal is an interrupt line for devices that want to trade their ability to master for a pin.
SMBALERT# is a wired-AND signal just as the SMBCLK and SMBDAT signals are. SMBALERT# is
used in conjunction with the SMBus General Call Address. Messages invoked with the SMBus are 2 bytes
long.
A slave-only device can signal the host through SMBALERT# that it wants to talk. The host processes the
interrupt and simultaneously accesses all SMBALERT# devices through the Alert Response Address
(ARA). Only the device(s) which pulled SMBALERT# low will acknowledge the Alert Response Address.
The host performs a modified Receive Byte operation. The 7 bit device address provided by the slave
transmit device is placed in the 7 most significant bits of the byte. The eighth bit can be a zero or one.</p>
<p>Returns 7 bit address of responding device.
Returns None if no response to ARA.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.alert_response_pec">
<code class="descname">alert_response_pec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.alert_response_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Alert Response Query to SMBALERT# interrupt with Packet Error Check.
Returns 7 bit address of responding device.
Returns None if no response to ARA.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.block_process_call">
<code class="descname">block_process_call</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteListWrite</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.block_process_call" title="Permalink to this definition">¶</a></dt>
<dd><p>The block write-block read process call is a two-part message. The call begins with a slave address and a
write condition. After the command code the host issues a write byte count (M) that describes how many
more bytes will be written in the first part of the message. If a master has 6 bytes to send, the byte count
field will have the value 6 (0000 0110b), followed by the 6 bytes of data. The write byte count (M) cannot
be zero.
The second part of the message is a block of read data beginning with a repeated start condition followed
by the slave address and a Read bit. The next byte is the read byte count (N), which may differ from the
write byte count (M). The read byte count (N) cannot be zero.
The combined data payload must not exceed 32 bytes. The byte length restrictions of this process call are
summarized as follows:
• M ≥ 1 byte
• N ≥ 1 byte
• M + N ≤ 32 bytes
The read byte count does not include the PEC byte. The PEC is computed on the total message beginning
with the first slave address and using the normal PEC computational rules. It is highly recommended that a
PEC byte be used with the Block Write-Block Read Process Call.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.block_process_call_pec">
<code class="descname">block_process_call_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteListWrite</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.block_process_call_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block write-block read process call with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.block_read">
<code class="descname">block_read</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.block_read" title="Permalink to this definition">¶</a></dt>
<dd><p>A Block Read differs from a block write in that the repeated START condition exists to satisfy the
requirement for a change in the transfer direction. A NACK immediately preceding the STOP condition
signifies the end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.block_read_pec">
<code class="descname">block_read_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.block_read_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block_read with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.block_write">
<code class="descname">block_write</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteList</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.block_write" title="Permalink to this definition">¶</a></dt>
<dd><p>The Block Write begins with a slave address and a write condition. After the command code the host
issues a byte count which describes how many more bytes will follow in the message. If a slave has 20
bytes to send, the byte count field will have the value 20 (14h), followed by the 20 bytes of data. The byte
count does not include the PEC byte. The byte count may not be 0. A Block Read or Write is allowed to
transfer a maximum of 32 data bytes.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.block_write_pec">
<code class="descname">block_write_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteList</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.block_write_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block_write with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.check_size">
<code class="descname">check_size</code><span class="sig-paren">(</span><em>data</em>, <em>bits</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.check_size" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure data fits within word of length  &#8220;bits&#8221;</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_buspirate.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.close" title="Permalink to this definition">¶</a></dt>
<dd><p>close the underlying (serial) interface</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.high_byte">
<code class="descname">high_byte</code><span class="sig-paren">(</span><em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.high_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Select upper byte from 16-bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.low_byte">
<code class="descname">low_byte</code><span class="sig-paren">(</span><em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.low_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Select lower byte from 16-bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.pec">
<code class="descname">pec</code><span class="sig-paren">(</span><em>byteList</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.pec" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference external" href="http://smbus.org/specs/smbus20.pdf">http://smbus.org/specs/smbus20.pdf</a>
Each bus transaction requires a Packet Error Code (PEC) calculation by both the transmitter and receiver
within each packet. The PEC uses an 8-bit cyclic redundancy check (CRC-8) of each read or write bus
transaction to calculate a Packet Error Code (PEC). The PEC may be calculated in any way that conforms
to a CRC-8 represented by the polynomial, C(x) = x8 + x2 + x1 + 1 and must be calculated in the order of
the bits as received.
Calculating the PEC for transmission or reception is implemented in a method chosen by the device
manufacturer. It is possible to perform the check with low-cost hardware or firmware algorithm that could
process the message bit-by-bit or with a byte-wise look-up table. The SMBus web page provides some
example CRC-8 methods.
The PEC is appended to the message as dictated by the protocols in section 5.5. The PEC calculation
includes all bytes in the transmission, including address, command and data. The PEC calculation does not
include ACK, NACK, START, STOP nor Repeated START bits. This means that the PEC is computed
over the entire message from the first START condition.
Whether a device implements packet error checking may be determined by the specification revision code
that is present in the SpecificationInfo() command for a Smart Battery, Smart Battery Charger or Smart
Battery Selector. See these individual specifications for exact revision coding identities. It may also be
discovered in the UDID, defined in section 5.6.1, for other devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.process_call">
<code class="descname">process_call</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.process_call" title="Permalink to this definition">¶</a></dt>
<dd><p>The process call is so named because a command sends data and waits for the slave to return a value
dependent on that data. The protocol is simply a Write Word followed by a Read Word without the Read-
Word command field and the Write-Word STOP bit.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.process_call_pec">
<code class="descname">process_call_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.process_call_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>process_call with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.quick_command_rd">
<code class="descname">quick_command_rd</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.quick_command_rd" title="Permalink to this definition">¶</a></dt>
<dd><p>Here, part of the slave address denotes the command – the R/W# bit. The R/W# bit may be used to simply
turn a device function on or off, or enable/disable a low-power standby mode. There is no data sent or
received.
The quick command implementation is good for very small devices that have limited support for the
SMBus specification. It also limits data on the bus for simple devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.quick_command_wr">
<code class="descname">quick_command_wr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.quick_command_wr" title="Permalink to this definition">¶</a></dt>
<dd><p>Here, part of the slave address denotes the command – the R/W# bit. The R/W# bit may be used to simply
turn a device function on or off, or enable/disable a low-power standby mode. There is no data sent or
received.
The quick command implementation is good for very small devices that have limited support for the
SMBus specification. It also limits data on the bus for simple devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.read_ack">
<code class="descname">read_ack</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_buspirate.read_ack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.read_ack" title="Permalink to this definition">¶</a></dt>
<dd><p>Read 8 bits from slave transmitter  and assert SDA during 9th acknowledge clock.  Returns 8 bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.read_addr">
<code class="descname">read_addr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.read_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>compute 8-bit read address from 7-bit address</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.read_byte">
<code class="descname">read_byte</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_buspirate.read_byte"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.read_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Reading data is slightly more complicated than writing data. First the host must write a command to the
slave device. Then it must follow that command with a repeated START condition to denote a read from
that device’s address. The slave then returns one byte of data.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.read_byte_list">
<code class="descname">read_byte_list</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.read_byte_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_byte results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.read_byte_list_pec">
<code class="descname">read_byte_list_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.read_byte_list_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_byte_pec results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.read_byte_pec">
<code class="descname">read_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.read_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>read_byte with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.read_nack">
<code class="descname">read_nack</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_buspirate.read_nack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.read_nack" title="Permalink to this definition">¶</a></dt>
<dd><p>Read 8 bits from slave transmitter  and release SDA during 9th acknowledge clock to request end of transmission.  Returns 8 bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.read_word">
<code class="descname">read_word</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_buspirate.read_word"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.read_word" title="Permalink to this definition">¶</a></dt>
<dd><p>Reading data is slightly more complicated than writing data. First the host must write a command to the
slave device. Then it must follow that command with a repeated START condition to denote a read from
that device’s address. The slave then returns two bytes of data.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.read_word_list">
<code class="descname">read_word_list</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.read_word_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_word results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.read_word_list_pec">
<code class="descname">read_word_list_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.read_word_list_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_word_pec results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.read_word_pec">
<code class="descname">read_word_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.read_word_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>read_word with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.receive_byte">
<code class="descname">receive_byte</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_buspirate.receive_byte"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.receive_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>The Receive Byte is similar to a Send Byte, the only difference being the direction of data transfer. A
simple device may have information that the host needs. It can do so with the Receive Byte protocol. The
same device may accept both Send Byte and Receive Byte protocols. A NACK (a ‘1’ in the ACK bit
position) signifies the end of a read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.receive_byte_pec">
<code class="descname">receive_byte_pec</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.receive_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>receive_byte with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.restart">
<code class="descname">restart</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.restart" title="Permalink to this definition">¶</a></dt>
<dd><p>I2C Re-Start  - Falling SDA with SCL high between start and stop condition.
Implement only if restart requires a different action than a normal start in underlying hardware.
Returns True or False to indicate successful arbitration</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.scan">
<code class="descname">scan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.scan" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all devices on bus by checking acknowledge of each address in turn.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.send_byte">
<code class="descname">send_byte</code><span class="sig-paren">(</span><em>addr7</em>, <em>data8</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_buspirate.send_byte"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.send_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple device may recognize its own slave address and accept up to 256 possible encoded commands in
the form of a byte that follows the slave address.
All or parts of the Send Byte may contribute to the command. For example, the highest 7 bits of the
command code might specify an access to a feature, while the least significant bit would tell the device to
turn the feature on or off. Or, a device may set the “volume” of its output based on the value it received
from the Send Byte protocol.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.send_byte_pec">
<code class="descname">send_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>data8</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.send_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>send_byte with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.start">
<code class="descname">start</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_buspirate.start"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.start" title="Permalink to this definition">¶</a></dt>
<dd><p>I2C Start  - Falling SDA with SCL high.  Returns True or False to indicate successful arbitration</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.stop">
<code class="descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_buspirate.stop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>I2C Start  - Rising SDA with SCL high.  Returns True or False to indicate successful arbitration</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.word">
<code class="descname">word</code><span class="sig-paren">(</span><em>lowByte</em>, <em>highByte</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.word" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 16-bit value from two SMBus bytes</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>data8</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_buspirate.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Transmit 8 bits plus 9th acknowledge clock.  Returns True or False to indicate slave acknowledge</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.write_addr">
<code class="descname">write_addr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.write_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>compute 8-bit write address from 7-bit address</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.write_byte">
<code class="descname">write_byte</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data8</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_buspirate.write_byte"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.write_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>The first byte of a Write Byte access is the command code. The next byte 
is the data to be written. In this example the master asserts the slave device address followed by the write
bit. The device acknowledges and the master delivers the command code. The slave again acknowledges
before the master sends the data byte. The slave acknowledges each byte, and the
entire transaction is finished with a STOP condition.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.write_byte_pec">
<code class="descname">write_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data8</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.write_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>write_byte with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.write_word">
<code class="descname">write_word</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_buspirate.write_word"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.write_word" title="Permalink to this definition">¶</a></dt>
<dd><p>The first byte of a Write Word access is the command code. The next two bytes
are the data to be written. In this example the master asserts the slave device address followed by the write
bit. The device acknowledges and the master delivers the command code. The slave again acknowledges
before the master sends the data word (low byte first). The slave acknowledges each byte, and the
entire transaction is finished with a STOP condition.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_buspirate.write_word_pec">
<code class="descname">write_word_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_buspirate.write_word_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>write_word with additional PEC byte written to slave.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyICe.twoWireInterface.i2c_dc590">
<em class="property">class </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">i2c_dc590</code><span class="sig-paren">(</span><em>interface_stream</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_dc590"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#PyICe.twoWireInterface.twoWireInterface" title="PyICe.twoWireInterface.twoWireInterface"><code class="xref py py-class docutils literal"><span class="pre">PyICe.twoWireInterface.twoWireInterface</span></code></a></p>
<p>Generic DC590/Linduino Driver.
Note that DC590 will not communicate unless it detects pullups on auxillary i2c port.
Linduino does not have above limitiation.</p>
<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.alert_response">
<code class="descname">alert_response</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.alert_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Another optional signal is an interrupt line for devices that want to trade their ability to master for a pin.
SMBALERT# is a wired-AND signal just as the SMBCLK and SMBDAT signals are. SMBALERT# is
used in conjunction with the SMBus General Call Address. Messages invoked with the SMBus are 2 bytes
long.
A slave-only device can signal the host through SMBALERT# that it wants to talk. The host processes the
interrupt and simultaneously accesses all SMBALERT# devices through the Alert Response Address
(ARA). Only the device(s) which pulled SMBALERT# low will acknowledge the Alert Response Address.
The host performs a modified Receive Byte operation. The 7 bit device address provided by the slave
transmit device is placed in the 7 most significant bits of the byte. The eighth bit can be a zero or one.</p>
<p>Returns 7 bit address of responding device.
Returns None if no response to ARA.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.alert_response_pec">
<code class="descname">alert_response_pec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.alert_response_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Alert Response Query to SMBALERT# interrupt with Packet Error Check.
Returns 7 bit address of responding device.
Returns None if no response to ARA.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.block_process_call">
<code class="descname">block_process_call</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteListWrite</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.block_process_call" title="Permalink to this definition">¶</a></dt>
<dd><p>The block write-block read process call is a two-part message. The call begins with a slave address and a
write condition. After the command code the host issues a write byte count (M) that describes how many
more bytes will be written in the first part of the message. If a master has 6 bytes to send, the byte count
field will have the value 6 (0000 0110b), followed by the 6 bytes of data. The write byte count (M) cannot
be zero.
The second part of the message is a block of read data beginning with a repeated start condition followed
by the slave address and a Read bit. The next byte is the read byte count (N), which may differ from the
write byte count (M). The read byte count (N) cannot be zero.
The combined data payload must not exceed 32 bytes. The byte length restrictions of this process call are
summarized as follows:
• M ≥ 1 byte
• N ≥ 1 byte
• M + N ≤ 32 bytes
The read byte count does not include the PEC byte. The PEC is computed on the total message beginning
with the first slave address and using the normal PEC computational rules. It is highly recommended that a
PEC byte be used with the Block Write-Block Read Process Call.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.block_process_call_pec">
<code class="descname">block_process_call_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteListWrite</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.block_process_call_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block write-block read process call with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.block_read">
<code class="descname">block_read</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.block_read" title="Permalink to this definition">¶</a></dt>
<dd><p>A Block Read differs from a block write in that the repeated START condition exists to satisfy the
requirement for a change in the transfer direction. A NACK immediately preceding the STOP condition
signifies the end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.block_read_pec">
<code class="descname">block_read_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.block_read_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block_read with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.block_write">
<code class="descname">block_write</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteList</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.block_write" title="Permalink to this definition">¶</a></dt>
<dd><p>The Block Write begins with a slave address and a write condition. After the command code the host
issues a byte count which describes how many more bytes will follow in the message. If a slave has 20
bytes to send, the byte count field will have the value 20 (14h), followed by the 20 bytes of data. The byte
count does not include the PEC byte. The byte count may not be 0. A Block Read or Write is allowed to
transfer a maximum of 32 data bytes.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.block_write_pec">
<code class="descname">block_write_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteList</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.block_write_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block_write with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.check_size">
<code class="descname">check_size</code><span class="sig-paren">(</span><em>data</em>, <em>bits</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.check_size" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure data fits within word of length  &#8220;bits&#8221;</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.close" title="Permalink to this definition">¶</a></dt>
<dd><p>close the underlying (serial) interface</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.high_byte">
<code class="descname">high_byte</code><span class="sig-paren">(</span><em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.high_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Select upper byte from 16-bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.i2c_mode">
<code class="descname">i2c_mode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_dc590.i2c_mode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.i2c_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Switch DC590 I2C/SPI mux to SPI</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.low_byte">
<code class="descname">low_byte</code><span class="sig-paren">(</span><em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.low_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Select lower byte from 16-bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.pec">
<code class="descname">pec</code><span class="sig-paren">(</span><em>byteList</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.pec" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference external" href="http://smbus.org/specs/smbus20.pdf">http://smbus.org/specs/smbus20.pdf</a>
Each bus transaction requires a Packet Error Code (PEC) calculation by both the transmitter and receiver
within each packet. The PEC uses an 8-bit cyclic redundancy check (CRC-8) of each read or write bus
transaction to calculate a Packet Error Code (PEC). The PEC may be calculated in any way that conforms
to a CRC-8 represented by the polynomial, C(x) = x8 + x2 + x1 + 1 and must be calculated in the order of
the bits as received.
Calculating the PEC for transmission or reception is implemented in a method chosen by the device
manufacturer. It is possible to perform the check with low-cost hardware or firmware algorithm that could
process the message bit-by-bit or with a byte-wise look-up table. The SMBus web page provides some
example CRC-8 methods.
The PEC is appended to the message as dictated by the protocols in section 5.5. The PEC calculation
includes all bytes in the transmission, including address, command and data. The PEC calculation does not
include ACK, NACK, START, STOP nor Repeated START bits. This means that the PEC is computed
over the entire message from the first START condition.
Whether a device implements packet error checking may be determined by the specification revision code
that is present in the SpecificationInfo() command for a Smart Battery, Smart Battery Charger or Smart
Battery Selector. See these individual specifications for exact revision coding identities. It may also be
discovered in the UDID, defined in section 5.6.1, for other devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.process_call">
<code class="descname">process_call</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.process_call" title="Permalink to this definition">¶</a></dt>
<dd><p>The process call is so named because a command sends data and waits for the slave to return a value
dependent on that data. The protocol is simply a Write Word followed by a Read Word without the Read-
Word command field and the Write-Word STOP bit.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.process_call_pec">
<code class="descname">process_call_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.process_call_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>process_call with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.quick_command_rd">
<code class="descname">quick_command_rd</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.quick_command_rd" title="Permalink to this definition">¶</a></dt>
<dd><p>Here, part of the slave address denotes the command – the R/W# bit. The R/W# bit may be used to simply
turn a device function on or off, or enable/disable a low-power standby mode. There is no data sent or
received.
The quick command implementation is good for very small devices that have limited support for the
SMBus specification. It also limits data on the bus for simple devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.quick_command_wr">
<code class="descname">quick_command_wr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.quick_command_wr" title="Permalink to this definition">¶</a></dt>
<dd><p>Here, part of the slave address denotes the command – the R/W# bit. The R/W# bit may be used to simply
turn a device function on or off, or enable/disable a low-power standby mode. There is no data sent or
received.
The quick command implementation is good for very small devices that have limited support for the
SMBus specification. It also limits data on the bus for simple devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.read_addr">
<code class="descname">read_addr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.read_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>compute 8-bit read address from 7-bit address</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.read_byte_list">
<code class="descname">read_byte_list</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.read_byte_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_byte results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.read_byte_list_pec">
<code class="descname">read_byte_list_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.read_byte_list_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_byte_pec results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.read_byte_pec">
<code class="descname">read_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_dc590.read_byte_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.read_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>SMBus Read Byte Protocol with Packet Error Checking.
Slave device address specified in 7-bit format.
Returns 8-bit data from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.read_word_list">
<code class="descname">read_word_list</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.read_word_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_word results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.read_word_list_pec">
<code class="descname">read_word_list_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.read_word_list_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_word_pec results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.read_word_pec">
<code class="descname">read_word_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_dc590.read_word_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.read_word_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>SMBus Read Word Protocol with Packet Error Checking.
Slave device address specified in 7-bit format.
Returns 16-bit data from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.receive_byte">
<code class="descname">receive_byte</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.receive_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>The Receive Byte is similar to a Send Byte, the only difference being the direction of data transfer. A
simple device may have information that the host needs. It can do so with the Receive Byte protocol. The
same device may accept both Send Byte and Receive Byte protocols. A NACK (a ‘1’ in the ACK bit
position) signifies the end of a read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.receive_byte_pec">
<code class="descname">receive_byte_pec</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.receive_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>receive_byte with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.restart">
<code class="descname">restart</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.restart" title="Permalink to this definition">¶</a></dt>
<dd><p>I2C Re-Start  - Falling SDA with SCL high between start and stop condition.
Implement only if restart requires a different action than a normal start in underlying hardware.
Returns True or False to indicate successful arbitration</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.scan">
<code class="descname">scan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.scan" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all devices on bus by checking acknowledge of each address in turn.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.send_byte_pec">
<code class="descname">send_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>data8</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.send_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>send_byte with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.word">
<code class="descname">word</code><span class="sig-paren">(</span><em>lowByte</em>, <em>highByte</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.word" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 16-bit value from two SMBus bytes</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590.write_addr">
<code class="descname">write_addr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590.write_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>compute 8-bit write address from 7-bit address</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read">
<em class="property">class </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">i2c_dc590_list_read</code><span class="sig-paren">(</span><em>interface_stream</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_dc590_list_read"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#PyICe.twoWireInterface.i2c_dc590" title="PyICe.twoWireInterface.i2c_dc590"><code class="xref py py-class docutils literal"><span class="pre">PyICe.twoWireInterface.i2c_dc590</span></code></a></p>
<p>use with Steve M&#8217;s linduino sketch extension DC590ListRead implementing ganged register reads
todo: add PEC support to .ino and Python.</p>
<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.alert_response">
<code class="descname">alert_response</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.alert_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Another optional signal is an interrupt line for devices that want to trade their ability to master for a pin.
SMBALERT# is a wired-AND signal just as the SMBCLK and SMBDAT signals are. SMBALERT# is
used in conjunction with the SMBus General Call Address. Messages invoked with the SMBus are 2 bytes
long.
A slave-only device can signal the host through SMBALERT# that it wants to talk. The host processes the
interrupt and simultaneously accesses all SMBALERT# devices through the Alert Response Address
(ARA). Only the device(s) which pulled SMBALERT# low will acknowledge the Alert Response Address.
The host performs a modified Receive Byte operation. The 7 bit device address provided by the slave
transmit device is placed in the 7 most significant bits of the byte. The eighth bit can be a zero or one.</p>
<p>Returns 7 bit address of responding device.
Returns None if no response to ARA.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.alert_response_pec">
<code class="descname">alert_response_pec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.alert_response_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Alert Response Query to SMBALERT# interrupt with Packet Error Check.
Returns 7 bit address of responding device.
Returns None if no response to ARA.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.block_process_call">
<code class="descname">block_process_call</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteListWrite</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.block_process_call" title="Permalink to this definition">¶</a></dt>
<dd><p>The block write-block read process call is a two-part message. The call begins with a slave address and a
write condition. After the command code the host issues a write byte count (M) that describes how many
more bytes will be written in the first part of the message. If a master has 6 bytes to send, the byte count
field will have the value 6 (0000 0110b), followed by the 6 bytes of data. The write byte count (M) cannot
be zero.
The second part of the message is a block of read data beginning with a repeated start condition followed
by the slave address and a Read bit. The next byte is the read byte count (N), which may differ from the
write byte count (M). The read byte count (N) cannot be zero.
The combined data payload must not exceed 32 bytes. The byte length restrictions of this process call are
summarized as follows:
• M ≥ 1 byte
• N ≥ 1 byte
• M + N ≤ 32 bytes
The read byte count does not include the PEC byte. The PEC is computed on the total message beginning
with the first slave address and using the normal PEC computational rules. It is highly recommended that a
PEC byte be used with the Block Write-Block Read Process Call.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.block_process_call_pec">
<code class="descname">block_process_call_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteListWrite</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.block_process_call_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block write-block read process call with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.block_read">
<code class="descname">block_read</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.block_read" title="Permalink to this definition">¶</a></dt>
<dd><p>A Block Read differs from a block write in that the repeated START condition exists to satisfy the
requirement for a change in the transfer direction. A NACK immediately preceding the STOP condition
signifies the end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.block_read_pec">
<code class="descname">block_read_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.block_read_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block_read with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.block_write">
<code class="descname">block_write</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteList</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.block_write" title="Permalink to this definition">¶</a></dt>
<dd><p>The Block Write begins with a slave address and a write condition. After the command code the host
issues a byte count which describes how many more bytes will follow in the message. If a slave has 20
bytes to send, the byte count field will have the value 20 (14h), followed by the 20 bytes of data. The byte
count does not include the PEC byte. The byte count may not be 0. A Block Read or Write is allowed to
transfer a maximum of 32 data bytes.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.block_write_pec">
<code class="descname">block_write_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteList</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.block_write_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block_write with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.check_size">
<code class="descname">check_size</code><span class="sig-paren">(</span><em>data</em>, <em>bits</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.check_size" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure data fits within word of length  &#8220;bits&#8221;</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.close" title="Permalink to this definition">¶</a></dt>
<dd><p>close the underlying (serial) interface</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.disable_streaming">
<code class="descname">disable_streaming</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_dc590_list_read.disable_streaming"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.disable_streaming" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn off streaming I2C data and flush buffers.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.enable_streaming_word_list">
<code class="descname">enable_streaming_word_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_dc590_list_read.enable_streaming_word_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.enable_streaming_word_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn on streaming I2C data
Uses the chip address and commandCode list set up with previous read_{word,byte}_list() command.
Not really compatible with PyICe except in I2C-only stand alone data logger mode.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.high_byte">
<code class="descname">high_byte</code><span class="sig-paren">(</span><em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.high_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Select upper byte from 16-bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.i2c_mode">
<code class="descname">i2c_mode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.i2c_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Switch DC590 I2C/SPI mux to SPI</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.low_byte">
<code class="descname">low_byte</code><span class="sig-paren">(</span><em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.low_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Select lower byte from 16-bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.pec">
<code class="descname">pec</code><span class="sig-paren">(</span><em>byteList</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.pec" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference external" href="http://smbus.org/specs/smbus20.pdf">http://smbus.org/specs/smbus20.pdf</a>
Each bus transaction requires a Packet Error Code (PEC) calculation by both the transmitter and receiver
within each packet. The PEC uses an 8-bit cyclic redundancy check (CRC-8) of each read or write bus
transaction to calculate a Packet Error Code (PEC). The PEC may be calculated in any way that conforms
to a CRC-8 represented by the polynomial, C(x) = x8 + x2 + x1 + 1 and must be calculated in the order of
the bits as received.
Calculating the PEC for transmission or reception is implemented in a method chosen by the device
manufacturer. It is possible to perform the check with low-cost hardware or firmware algorithm that could
process the message bit-by-bit or with a byte-wise look-up table. The SMBus web page provides some
example CRC-8 methods.
The PEC is appended to the message as dictated by the protocols in section 5.5. The PEC calculation
includes all bytes in the transmission, including address, command and data. The PEC calculation does not
include ACK, NACK, START, STOP nor Repeated START bits. This means that the PEC is computed
over the entire message from the first START condition.
Whether a device implements packet error checking may be determined by the specification revision code
that is present in the SpecificationInfo() command for a Smart Battery, Smart Battery Charger or Smart
Battery Selector. See these individual specifications for exact revision coding identities. It may also be
discovered in the UDID, defined in section 5.6.1, for other devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.process_call">
<code class="descname">process_call</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.process_call" title="Permalink to this definition">¶</a></dt>
<dd><p>The process call is so named because a command sends data and waits for the slave to return a value
dependent on that data. The protocol is simply a Write Word followed by a Read Word without the Read-
Word command field and the Write-Word STOP bit.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.process_call_pec">
<code class="descname">process_call_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.process_call_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>process_call with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.quick_command_rd">
<code class="descname">quick_command_rd</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.quick_command_rd" title="Permalink to this definition">¶</a></dt>
<dd><p>Here, part of the slave address denotes the command – the R/W# bit. The R/W# bit may be used to simply
turn a device function on or off, or enable/disable a low-power standby mode. There is no data sent or
received.
The quick command implementation is good for very small devices that have limited support for the
SMBus specification. It also limits data on the bus for simple devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.quick_command_wr">
<code class="descname">quick_command_wr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.quick_command_wr" title="Permalink to this definition">¶</a></dt>
<dd><p>Here, part of the slave address denotes the command – the R/W# bit. The R/W# bit may be used to simply
turn a device function on or off, or enable/disable a low-power standby mode. There is no data sent or
received.
The quick command implementation is good for very small devices that have limited support for the
SMBus specification. It also limits data on the bus for simple devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.read_addr">
<code class="descname">read_addr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.read_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>compute 8-bit read address from 7-bit address</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.read_byte_list">
<code class="descname">read_byte_list</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em>, <em>PEC=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_dc590_list_read.read_byte_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.read_byte_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_byte results.  
Reads each commandCode of cc_list in turn at chip address addr7
This method overloads twoWireInterface.read_byte_list() to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.read_byte_list_pec">
<code class="descname">read_byte_list_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_dc590_list_read.read_byte_list_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.read_byte_list_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_byte results.  
Reads each commandCode of cc_list in turn at chip address addr7
This method overloads twoWireInterface.read_byte_list_pec() to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.read_byte_pec">
<code class="descname">read_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.read_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>SMBus Read Byte Protocol with Packet Error Checking.
Slave device address specified in 7-bit format.
Returns 8-bit data from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.read_streaming_byte_list">
<code class="descname">read_streaming_byte_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_dc590_list_read.read_streaming_byte_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.read_streaming_byte_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Incomplete stream read handler.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.read_streaming_byte_list_pec">
<code class="descname">read_streaming_byte_list_pec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_dc590_list_read.read_streaming_byte_list_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.read_streaming_byte_list_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Incomplete stream read handler.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.read_streaming_word_list">
<code class="descname">read_streaming_word_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_dc590_list_read.read_streaming_word_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.read_streaming_word_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of single read results.
Expects streaming to have been previously enabled using enable_streaming_word_list()
This method must be called often enough in the main loop to keep buffers from overflowing.
The main loop should spend time here on blocking IO as data fills the serial buffer if the computer is fast enough to keep up.
Not really compatible with PyICe except in I2C-only stand alone data logger mode because of this blocking IO speed requirement.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.read_streaming_word_list_pec">
<code class="descname">read_streaming_word_list_pec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_dc590_list_read.read_streaming_word_list_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.read_streaming_word_list_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Incomplete stream read handler.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.read_word_list">
<code class="descname">read_word_list</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em>, <em>PEC=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_dc590_list_read.read_word_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.read_word_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_word results.  
Reads each commandCode of cc_list in turn at chip address addr7
This method overloads twoWireInterface.read_word_list() to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.read_word_list_pec">
<code class="descname">read_word_list_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_dc590_list_read.read_word_list_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.read_word_list_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_word results.  
Reads each commandCode of cc_list in turn at chip address addr7
This method overloads twoWireInterface.read_word_list_pec() to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.read_word_pec">
<code class="descname">read_word_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.read_word_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>SMBus Read Word Protocol with Packet Error Checking.
Slave device address specified in 7-bit format.
Returns 16-bit data from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.receive_byte">
<code class="descname">receive_byte</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.receive_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>The Receive Byte is similar to a Send Byte, the only difference being the direction of data transfer. A
simple device may have information that the host needs. It can do so with the Receive Byte protocol. The
same device may accept both Send Byte and Receive Byte protocols. A NACK (a ‘1’ in the ACK bit
position) signifies the end of a read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.receive_byte_pec">
<code class="descname">receive_byte_pec</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.receive_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>receive_byte with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.restart">
<code class="descname">restart</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.restart" title="Permalink to this definition">¶</a></dt>
<dd><p>I2C Re-Start  - Falling SDA with SCL high between start and stop condition.
Implement only if restart requires a different action than a normal start in underlying hardware.
Returns True or False to indicate successful arbitration</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.scan">
<code class="descname">scan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.scan" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all devices on bus by checking acknowledge of each address in turn.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.send_byte_pec">
<code class="descname">send_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>data8</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.send_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>send_byte with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.word">
<code class="descname">word</code><span class="sig-paren">(</span><em>lowByte</em>, <em>highByte</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.word" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 16-bit value from two SMBus bytes</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dc590_list_read.write_addr">
<code class="descname">write_addr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dc590_list_read.write_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>compute 8-bit write address from 7-bit address</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyICe.twoWireInterface.i2c_dummy">
<em class="property">class </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">i2c_dummy</code><span class="sig-paren">(</span><em>delay=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_dummy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#PyICe.twoWireInterface.twoWireInterface" title="PyICe.twoWireInterface.twoWireInterface"><code class="xref py py-class docutils literal"><span class="pre">PyICe.twoWireInterface.twoWireInterface</span></code></a></p>
<p>dummy interface for testing without any hardware.  No actual communication occurs.</p>
<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.alert_response">
<code class="descname">alert_response</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.alert_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Another optional signal is an interrupt line for devices that want to trade their ability to master for a pin.
SMBALERT# is a wired-AND signal just as the SMBCLK and SMBDAT signals are. SMBALERT# is
used in conjunction with the SMBus General Call Address. Messages invoked with the SMBus are 2 bytes
long.
A slave-only device can signal the host through SMBALERT# that it wants to talk. The host processes the
interrupt and simultaneously accesses all SMBALERT# devices through the Alert Response Address
(ARA). Only the device(s) which pulled SMBALERT# low will acknowledge the Alert Response Address.
The host performs a modified Receive Byte operation. The 7 bit device address provided by the slave
transmit device is placed in the 7 most significant bits of the byte. The eighth bit can be a zero or one.</p>
<p>Returns 7 bit address of responding device.
Returns None if no response to ARA.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.alert_response_pec">
<code class="descname">alert_response_pec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.alert_response_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Alert Response Query to SMBALERT# interrupt with Packet Error Check.
Returns 7 bit address of responding device.
Returns None if no response to ARA.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.block_process_call">
<code class="descname">block_process_call</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteListWrite</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.block_process_call" title="Permalink to this definition">¶</a></dt>
<dd><p>The block write-block read process call is a two-part message. The call begins with a slave address and a
write condition. After the command code the host issues a write byte count (M) that describes how many
more bytes will be written in the first part of the message. If a master has 6 bytes to send, the byte count
field will have the value 6 (0000 0110b), followed by the 6 bytes of data. The write byte count (M) cannot
be zero.
The second part of the message is a block of read data beginning with a repeated start condition followed
by the slave address and a Read bit. The next byte is the read byte count (N), which may differ from the
write byte count (M). The read byte count (N) cannot be zero.
The combined data payload must not exceed 32 bytes. The byte length restrictions of this process call are
summarized as follows:
• M ≥ 1 byte
• N ≥ 1 byte
• M + N ≤ 32 bytes
The read byte count does not include the PEC byte. The PEC is computed on the total message beginning
with the first slave address and using the normal PEC computational rules. It is highly recommended that a
PEC byte be used with the Block Write-Block Read Process Call.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.block_process_call_pec">
<code class="descname">block_process_call_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteListWrite</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.block_process_call_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block write-block read process call with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.block_read">
<code class="descname">block_read</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.block_read" title="Permalink to this definition">¶</a></dt>
<dd><p>A Block Read differs from a block write in that the repeated START condition exists to satisfy the
requirement for a change in the transfer direction. A NACK immediately preceding the STOP condition
signifies the end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.block_read_pec">
<code class="descname">block_read_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.block_read_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block_read with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.block_write">
<code class="descname">block_write</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteList</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.block_write" title="Permalink to this definition">¶</a></dt>
<dd><p>The Block Write begins with a slave address and a write condition. After the command code the host
issues a byte count which describes how many more bytes will follow in the message. If a slave has 20
bytes to send, the byte count field will have the value 20 (14h), followed by the 20 bytes of data. The byte
count does not include the PEC byte. The byte count may not be 0. A Block Read or Write is allowed to
transfer a maximum of 32 data bytes.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.block_write_pec">
<code class="descname">block_write_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteList</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.block_write_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block_write with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.check_size">
<code class="descname">check_size</code><span class="sig-paren">(</span><em>data</em>, <em>bits</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.check_size" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure data fits within word of length  &#8220;bits&#8221;</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.close" title="Permalink to this definition">¶</a></dt>
<dd><p>close the underlying (serial) interface</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.high_byte">
<code class="descname">high_byte</code><span class="sig-paren">(</span><em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.high_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Select upper byte from 16-bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.low_byte">
<code class="descname">low_byte</code><span class="sig-paren">(</span><em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.low_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Select lower byte from 16-bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.pec">
<code class="descname">pec</code><span class="sig-paren">(</span><em>byteList</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.pec" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference external" href="http://smbus.org/specs/smbus20.pdf">http://smbus.org/specs/smbus20.pdf</a>
Each bus transaction requires a Packet Error Code (PEC) calculation by both the transmitter and receiver
within each packet. The PEC uses an 8-bit cyclic redundancy check (CRC-8) of each read or write bus
transaction to calculate a Packet Error Code (PEC). The PEC may be calculated in any way that conforms
to a CRC-8 represented by the polynomial, C(x) = x8 + x2 + x1 + 1 and must be calculated in the order of
the bits as received.
Calculating the PEC for transmission or reception is implemented in a method chosen by the device
manufacturer. It is possible to perform the check with low-cost hardware or firmware algorithm that could
process the message bit-by-bit or with a byte-wise look-up table. The SMBus web page provides some
example CRC-8 methods.
The PEC is appended to the message as dictated by the protocols in section 5.5. The PEC calculation
includes all bytes in the transmission, including address, command and data. The PEC calculation does not
include ACK, NACK, START, STOP nor Repeated START bits. This means that the PEC is computed
over the entire message from the first START condition.
Whether a device implements packet error checking may be determined by the specification revision code
that is present in the SpecificationInfo() command for a Smart Battery, Smart Battery Charger or Smart
Battery Selector. See these individual specifications for exact revision coding identities. It may also be
discovered in the UDID, defined in section 5.6.1, for other devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.process_call">
<code class="descname">process_call</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.process_call" title="Permalink to this definition">¶</a></dt>
<dd><p>The process call is so named because a command sends data and waits for the slave to return a value
dependent on that data. The protocol is simply a Write Word followed by a Read Word without the Read-
Word command field and the Write-Word STOP bit.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.process_call_pec">
<code class="descname">process_call_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.process_call_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>process_call with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.quick_command_rd">
<code class="descname">quick_command_rd</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.quick_command_rd" title="Permalink to this definition">¶</a></dt>
<dd><p>Here, part of the slave address denotes the command – the R/W# bit. The R/W# bit may be used to simply
turn a device function on or off, or enable/disable a low-power standby mode. There is no data sent or
received.
The quick command implementation is good for very small devices that have limited support for the
SMBus specification. It also limits data on the bus for simple devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.quick_command_wr">
<code class="descname">quick_command_wr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.quick_command_wr" title="Permalink to this definition">¶</a></dt>
<dd><p>Here, part of the slave address denotes the command – the R/W# bit. The R/W# bit may be used to simply
turn a device function on or off, or enable/disable a low-power standby mode. There is no data sent or
received.
The quick command implementation is good for very small devices that have limited support for the
SMBus specification. It also limits data on the bus for simple devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.read_ack">
<code class="descname">read_ack</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_dummy.read_ack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.read_ack" title="Permalink to this definition">¶</a></dt>
<dd><p>don&#8217;t do anything.  Return random 8-bit value</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.read_addr">
<code class="descname">read_addr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.read_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>compute 8-bit read address from 7-bit address</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.read_byte">
<code class="descname">read_byte</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.read_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Reading data is slightly more complicated than writing data. First the host must write a command to the
slave device. Then it must follow that command with a repeated START condition to denote a read from
that device’s address. The slave then returns one byte of data.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.read_byte_list">
<code class="descname">read_byte_list</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.read_byte_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_byte results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.read_byte_list_pec">
<code class="descname">read_byte_list_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.read_byte_list_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_byte_pec results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.read_byte_pec">
<code class="descname">read_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.read_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>read_byte with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.read_nack">
<code class="descname">read_nack</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_dummy.read_nack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.read_nack" title="Permalink to this definition">¶</a></dt>
<dd><p>don&#8217;t do anything.  Return random 8-bit value</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.read_word">
<code class="descname">read_word</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.read_word" title="Permalink to this definition">¶</a></dt>
<dd><p>Reading data is slightly more complicated than writing data. First the host must write a command to the
slave device. Then it must follow that command with a repeated START condition to denote a read from
that device’s address. The slave then returns two bytes of data.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.read_word_list">
<code class="descname">read_word_list</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.read_word_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_word results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.read_word_list_pec">
<code class="descname">read_word_list_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.read_word_list_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_word_pec results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.read_word_pec">
<code class="descname">read_word_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.read_word_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>read_word with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.receive_byte">
<code class="descname">receive_byte</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.receive_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>The Receive Byte is similar to a Send Byte, the only difference being the direction of data transfer. A
simple device may have information that the host needs. It can do so with the Receive Byte protocol. The
same device may accept both Send Byte and Receive Byte protocols. A NACK (a ‘1’ in the ACK bit
position) signifies the end of a read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.receive_byte_pec">
<code class="descname">receive_byte_pec</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.receive_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>receive_byte with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.restart">
<code class="descname">restart</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.restart" title="Permalink to this definition">¶</a></dt>
<dd><p>I2C Re-Start  - Falling SDA with SCL high between start and stop condition.
Implement only if restart requires a different action than a normal start in underlying hardware.
Returns True or False to indicate successful arbitration</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.resync_communication">
<code class="descname">resync_communication</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_dummy.resync_communication"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.resync_communication" title="Permalink to this definition">¶</a></dt>
<dd><p>don&#8217;t do anything.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.scan">
<code class="descname">scan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.scan" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all devices on bus by checking acknowledge of each address in turn.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.send_byte">
<code class="descname">send_byte</code><span class="sig-paren">(</span><em>addr7</em>, <em>data8</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.send_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple device may recognize its own slave address and accept up to 256 possible encoded commands in
the form of a byte that follows the slave address.
All or parts of the Send Byte may contribute to the command. For example, the highest 7 bits of the
command code might specify an access to a feature, while the least significant bit would tell the device to
turn the feature on or off. Or, a device may set the “volume” of its output based on the value it received
from the Send Byte protocol.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.send_byte_pec">
<code class="descname">send_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>data8</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.send_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>send_byte with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.start">
<code class="descname">start</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_dummy.start"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.start" title="Permalink to this definition">¶</a></dt>
<dd><p>don&#8217;t do anything.  Return value indicates that transaction was successful.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.stop">
<code class="descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_dummy.stop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>don&#8217;t do anything.  Return value indicates that transaction was successful.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.word">
<code class="descname">word</code><span class="sig-paren">(</span><em>lowByte</em>, <em>highByte</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.word" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 16-bit value from two SMBus bytes</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>data8</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_dummy.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.write" title="Permalink to this definition">¶</a></dt>
<dd><p>don&#8217;t do anything.  Return value indicates that transaction was successful.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.write_addr">
<code class="descname">write_addr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.write_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>compute 8-bit write address from 7-bit address</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.write_byte">
<code class="descname">write_byte</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data8</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.write_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>The first byte of a Write Byte access is the command code. The next byte 
is the data to be written. In this example the master asserts the slave device address followed by the write
bit. The device acknowledges and the master delivers the command code. The slave again acknowledges
before the master sends the data byte. The slave acknowledges each byte, and the
entire transaction is finished with a STOP condition.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.write_byte_pec">
<code class="descname">write_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data8</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.write_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>write_byte with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.write_word">
<code class="descname">write_word</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.write_word" title="Permalink to this definition">¶</a></dt>
<dd><p>The first byte of a Write Word access is the command code. The next two bytes
are the data to be written. In this example the master asserts the slave device address followed by the write
bit. The device acknowledges and the master delivers the command code. The slave again acknowledges
before the master sends the data word (low byte first). The slave acknowledges each byte, and the
entire transaction is finished with a STOP condition.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_dummy.write_word_pec">
<code class="descname">write_word_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_dummy.write_word_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>write_word with additional PEC byte written to slave.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyICe.twoWireInterface.i2c_kernel">
<em class="property">class </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">i2c_kernel</code><span class="sig-paren">(</span><em>bus_number</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#PyICe.twoWireInterface.twoWireInterface" title="PyICe.twoWireInterface.twoWireInterface"><code class="xref py py-class docutils literal"><span class="pre">PyICe.twoWireInterface.twoWireInterface</span></code></a></p>
<p>communication class using Linux kernel driver
requires py-smbus library provided as part of lm-sensors project i2c-tools library
you may need to go to PyICe/deps/i2c-tools and build i2c-tools and py-smbus on your machine before this will work (Make/gcc)
alternatively, install python-smbus and i2c-tools from your distribution&#8217;s package manager (apt-get,yum,opkg,port,etc).
note that the library names for the various protocols do not match the SMBus protocol specification.</p>
<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.alert_response">
<code class="descname">alert_response</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel.alert_response"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.alert_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Another optional signal is an interrupt line for devices that want to trade their ability to master for a pin.
SMBALERT# is a wired-AND signal just as the SMBCLK and SMBDAT signals are. SMBALERT# is
used in conjunction with the SMBus General Call Address. Messages invoked with the SMBus are 2 bytes
long.
A slave-only device can signal the host through SMBALERT# that it wants to talk. The host processes the
interrupt and simultaneously accesses all SMBALERT# devices through the Alert Response Address
(ARA). Only the device(s) which pulled SMBALERT# low will acknowledge the Alert Response Address.
The host performs a modified Receive Byte operation. The 7 bit device address provided by the slave
transmit device is placed in the 7 most significant bits of the byte. The eighth bit can be a zero or one.</p>
<p>Returns 7 bit address of responding device.
Returns None if no response to ARA</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.alert_response_pec">
<code class="descname">alert_response_pec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel.alert_response_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.alert_response_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Alert Response Query to SMBALERT# interrupt with Packet Error Check</p>
<p>Returns 7 bit address of responding device.
Returns None if no response to ARA</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.block_process_call">
<code class="descname">block_process_call</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteListWrite</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel.block_process_call"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.block_process_call" title="Permalink to this definition">¶</a></dt>
<dd><p>The block write-block read process call is a two-part message. The call begins with a slave address and a
write condition. After the command code the host issues a write byte count (M) that describes how many
more bytes will be written in the first part of the message. If a master has 6 bytes to send, the byte count
field will have the value 6 (0000 0110b), followed by the 6 bytes of data. The write byte count (M) cannot
be zero.
The second part of the message is a block of read data beginning with a repeated start condition followed
by the slave address and a Read bit. The next byte is the read byte count (N), which may differ from the
write byte count (M). The read byte count (N) cannot be zero.
The combined data payload must not exceed 32 bytes. The byte length restrictions of this process call are
summarized as follows:
• M ≥ 1 byte
• N ≥ 1 byte
• M + N ≤ 32 bytes
The read byte count does not include the PEC byte. The PEC is computed on the total message beginning
with the first slave address and using the normal PEC computational rules. It is highly recommended that a
PEC byte be used with the Block Write-Block Read Process Call.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.block_process_call_pec">
<code class="descname">block_process_call_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteListWrite</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel.block_process_call_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.block_process_call_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block write-block read process call with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.block_read">
<code class="descname">block_read</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel.block_read"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.block_read" title="Permalink to this definition">¶</a></dt>
<dd><p>A Block Read differs from a block write in that the repeated START condition exists to satisfy the
requirement for a change in the transfer direction. A NACK immediately preceding the STOP condition
signifies the end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.block_read_pec">
<code class="descname">block_read_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel.block_read_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.block_read_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block_read with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.block_write">
<code class="descname">block_write</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteList</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel.block_write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.block_write" title="Permalink to this definition">¶</a></dt>
<dd><p>The Block Write begins with a slave address and a write condition. After the command code the host
issues a byte count which describes how many more bytes will follow in the message. If a slave has 20
bytes to send, the byte count field will have the value 20 (14h), followed by the 20 bytes of data. The byte
count does not include the PEC byte. The byte count may not be 0. A Block Read or Write is allowed to
transfer a maximum of 32 data bytes.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.block_write_pec">
<code class="descname">block_write_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteList</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel.block_write_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.block_write_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block_write with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.check_size">
<code class="descname">check_size</code><span class="sig-paren">(</span><em>data</em>, <em>bits</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.check_size" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure data fits within word of length  &#8220;bits&#8221;</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.close" title="Permalink to this definition">¶</a></dt>
<dd><p>close the underlying (serial) interface</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.high_byte">
<code class="descname">high_byte</code><span class="sig-paren">(</span><em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.high_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Select upper byte from 16-bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.low_byte">
<code class="descname">low_byte</code><span class="sig-paren">(</span><em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.low_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Select lower byte from 16-bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.pec">
<code class="descname">pec</code><span class="sig-paren">(</span><em>byteList</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.pec" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference external" href="http://smbus.org/specs/smbus20.pdf">http://smbus.org/specs/smbus20.pdf</a>
Each bus transaction requires a Packet Error Code (PEC) calculation by both the transmitter and receiver
within each packet. The PEC uses an 8-bit cyclic redundancy check (CRC-8) of each read or write bus
transaction to calculate a Packet Error Code (PEC). The PEC may be calculated in any way that conforms
to a CRC-8 represented by the polynomial, C(x) = x8 + x2 + x1 + 1 and must be calculated in the order of
the bits as received.
Calculating the PEC for transmission or reception is implemented in a method chosen by the device
manufacturer. It is possible to perform the check with low-cost hardware or firmware algorithm that could
process the message bit-by-bit or with a byte-wise look-up table. The SMBus web page provides some
example CRC-8 methods.
The PEC is appended to the message as dictated by the protocols in section 5.5. The PEC calculation
includes all bytes in the transmission, including address, command and data. The PEC calculation does not
include ACK, NACK, START, STOP nor Repeated START bits. This means that the PEC is computed
over the entire message from the first START condition.
Whether a device implements packet error checking may be determined by the specification revision code
that is present in the SpecificationInfo() command for a Smart Battery, Smart Battery Charger or Smart
Battery Selector. See these individual specifications for exact revision coding identities. It may also be
discovered in the UDID, defined in section 5.6.1, for other devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.process_call">
<code class="descname">process_call</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel.process_call"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.process_call" title="Permalink to this definition">¶</a></dt>
<dd><p>The process call is so named because a command sends data and waits for the slave to return a value
dependent on that data. The protocol is simply a Write Word followed by a Read Word without the Read-
Word command field and the Write-Word STOP bit.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.process_call_pec">
<code class="descname">process_call_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel.process_call_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.process_call_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>process_call with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.quick_command_rd">
<code class="descname">quick_command_rd</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.quick_command_rd" title="Permalink to this definition">¶</a></dt>
<dd><p>Here, part of the slave address denotes the command – the R/W# bit. The R/W# bit may be used to simply
turn a device function on or off, or enable/disable a low-power standby mode. There is no data sent or
received.
The quick command implementation is good for very small devices that have limited support for the
SMBus specification. It also limits data on the bus for simple devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.quick_command_wr">
<code class="descname">quick_command_wr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel.quick_command_wr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.quick_command_wr" title="Permalink to this definition">¶</a></dt>
<dd><p>Here, part of the slave address denotes the command – the R/W# bit. The R/W# bit may be used to simply
turn a device function on or off, or enable/disable a low-power standby mode. There is no data sent or
received.
The quick command implementation is good for very small devices that have limited support for the
SMBus specification. It also limits data on the bus for simple devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.read_ack">
<code class="descname">read_ack</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.read_ack" title="Permalink to this definition">¶</a></dt>
<dd><p>Read 8 bits from slave transmitter  and assert SDA during 9th acknowledge clock.  Returns 8 bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.read_addr">
<code class="descname">read_addr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.read_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>compute 8-bit read address from 7-bit address</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.read_byte">
<code class="descname">read_byte</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel.read_byte"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.read_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Reading data is slightly more complicated than writing data. First the host must write a command to the
slave device. Then it must follow that command with a repeated START condition to denote a read from
that device’s address. The slave then returns one byte of data.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.read_byte_list">
<code class="descname">read_byte_list</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.read_byte_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_byte results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.read_byte_list_pec">
<code class="descname">read_byte_list_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.read_byte_list_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_byte_pec results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.read_byte_pec">
<code class="descname">read_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel.read_byte_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.read_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>read_byte with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.read_nack">
<code class="descname">read_nack</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.read_nack" title="Permalink to this definition">¶</a></dt>
<dd><p>Read 8 bits from slave transmitter  and release SDA during 9th acknowledge clock to request end of transmission.  Returns 8 bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.read_word">
<code class="descname">read_word</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel.read_word"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.read_word" title="Permalink to this definition">¶</a></dt>
<dd><p>Reading data is slightly more complicated than writing data. First the host must write a command to the
slave device. Then it must follow that command with a repeated START condition to denote a read from
that device’s address. The slave then returns two bytes of data.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.read_word_list">
<code class="descname">read_word_list</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.read_word_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_word results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.read_word_list_pec">
<code class="descname">read_word_list_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.read_word_list_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_word_pec results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.read_word_pec">
<code class="descname">read_word_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel.read_word_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.read_word_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>read_word with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.receive_byte">
<code class="descname">receive_byte</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel.receive_byte"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.receive_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>The Receive Byte is similar to a Send Byte, the only difference being the direction of data transfer. A
simple device may have information that the host needs. It can do so with the Receive Byte protocol. The
same device may accept both Send Byte and Receive Byte protocols. A NACK (a ‘1’ in the ACK bit
position) signifies the end of a read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.receive_byte_pec">
<code class="descname">receive_byte_pec</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel.receive_byte_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.receive_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>receive_byte with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.restart">
<code class="descname">restart</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.restart" title="Permalink to this definition">¶</a></dt>
<dd><p>I2C Re-Start  - Falling SDA with SCL high between start and stop condition.
Implement only if restart requires a different action than a normal start in underlying hardware.
Returns True or False to indicate successful arbitration</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.resync_communication">
<code class="descname">resync_communication</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.resync_communication" title="Permalink to this definition">¶</a></dt>
<dd><p>attempt to correct problems caused by dropped/duplicate characters in serial buffer, etc.
Don&#8217;t do anything here.  Method must be overloaded to implement hardware-specific recovery procedure.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.scan">
<code class="descname">scan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.scan" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all devices on bus by checking acknowledge of each address in turn.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.send_byte">
<code class="descname">send_byte</code><span class="sig-paren">(</span><em>addr7</em>, <em>data8</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel.send_byte"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.send_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple device may recognize its own slave address and accept up to 256 possible encoded commands in
the form of a byte that follows the slave address.
All or parts of the Send Byte may contribute to the command. For example, the highest 7 bits of the
command code might specify an access to a feature, while the least significant bit would tell the device to
turn the feature on or off. Or, a device may set the “volume” of its output based on the value it received
from the Send Byte protocol.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.send_byte_pec">
<code class="descname">send_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>data8</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel.send_byte_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.send_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>send_byte with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.start">
<code class="descname">start</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.start" title="Permalink to this definition">¶</a></dt>
<dd><p>I2C Start  - Falling SDA with SCL high.  Returns True or False to indicate successful arbitration</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.stop">
<code class="descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>I2C Stop  - Rising SDA with SCL high.  Returns True or False to indicate successful arbitration</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.word">
<code class="descname">word</code><span class="sig-paren">(</span><em>lowByte</em>, <em>highByte</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.word" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 16-bit value from two SMBus bytes</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>data8</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Transmit 8 bits plus 9th acknowledge clock.  Returns True or False to indicate slave acknowledge</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.write_addr">
<code class="descname">write_addr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.write_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>compute 8-bit write address from 7-bit address</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.write_byte">
<code class="descname">write_byte</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data8</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel.write_byte"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.write_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>The first byte of a Write Byte access is the command code. The next byte 
is the data to be written. In this example the master asserts the slave device address followed by the write
bit. The device acknowledges and the master delivers the command code. The slave again acknowledges
before the master sends the data byte. The slave acknowledges each byte, and the
entire transaction is finished with a STOP condition.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.write_byte_pec">
<code class="descname">write_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data8</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel.write_byte_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.write_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>write_byte with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.write_word">
<code class="descname">write_word</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel.write_word"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.write_word" title="Permalink to this definition">¶</a></dt>
<dd><p>The first byte of a Write Word access is the command code. The next two bytes
are the data to be written. In this example the master asserts the slave device address followed by the write
bit. The device acknowledges and the master delivers the command code. The slave again acknowledges
before the master sends the data word (low byte first). The slave acknowledges each byte, and the
entire transaction is finished with a STOP condition.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_kernel.write_word_pec">
<code class="descname">write_word_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_kernel.write_word_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_kernel.write_word_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>write_word with additional PEC byte written to slave.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyICe.twoWireInterface.i2c_pic">
<em class="property">class </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">i2c_pic</code><span class="sig-paren">(</span><em>interface_raw_serial</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_pic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#PyICe.twoWireInterface.twoWireInterface" title="PyICe.twoWireInterface.twoWireInterface"><code class="xref py py-class docutils literal"><span class="pre">PyICe.twoWireInterface.twoWireInterface</span></code></a></p>
<p>communication class to simplify talking to dave&#8217;s external i2c interface firmware on George&#8217;s development board (pic18F4553 and similar)
requires pySerial</p>
<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.alert_response">
<code class="descname">alert_response</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.alert_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Another optional signal is an interrupt line for devices that want to trade their ability to master for a pin.
SMBALERT# is a wired-AND signal just as the SMBCLK and SMBDAT signals are. SMBALERT# is
used in conjunction with the SMBus General Call Address. Messages invoked with the SMBus are 2 bytes
long.
A slave-only device can signal the host through SMBALERT# that it wants to talk. The host processes the
interrupt and simultaneously accesses all SMBALERT# devices through the Alert Response Address
(ARA). Only the device(s) which pulled SMBALERT# low will acknowledge the Alert Response Address.
The host performs a modified Receive Byte operation. The 7 bit device address provided by the slave
transmit device is placed in the 7 most significant bits of the byte. The eighth bit can be a zero or one.</p>
<p>Returns 7 bit address of responding device.
Returns None if no response to ARA.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.alert_response_pec">
<code class="descname">alert_response_pec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.alert_response_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Alert Response Query to SMBALERT# interrupt with Packet Error Check.
Returns 7 bit address of responding device.
Returns None if no response to ARA.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.block_process_call">
<code class="descname">block_process_call</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteListWrite</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.block_process_call" title="Permalink to this definition">¶</a></dt>
<dd><p>The block write-block read process call is a two-part message. The call begins with a slave address and a
write condition. After the command code the host issues a write byte count (M) that describes how many
more bytes will be written in the first part of the message. If a master has 6 bytes to send, the byte count
field will have the value 6 (0000 0110b), followed by the 6 bytes of data. The write byte count (M) cannot
be zero.
The second part of the message is a block of read data beginning with a repeated start condition followed
by the slave address and a Read bit. The next byte is the read byte count (N), which may differ from the
write byte count (M). The read byte count (N) cannot be zero.
The combined data payload must not exceed 32 bytes. The byte length restrictions of this process call are
summarized as follows:
• M ≥ 1 byte
• N ≥ 1 byte
• M + N ≤ 32 bytes
The read byte count does not include the PEC byte. The PEC is computed on the total message beginning
with the first slave address and using the normal PEC computational rules. It is highly recommended that a
PEC byte be used with the Block Write-Block Read Process Call.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.block_process_call_pec">
<code class="descname">block_process_call_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteListWrite</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.block_process_call_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block write-block read process call with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.block_read">
<code class="descname">block_read</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.block_read" title="Permalink to this definition">¶</a></dt>
<dd><p>A Block Read differs from a block write in that the repeated START condition exists to satisfy the
requirement for a change in the transfer direction. A NACK immediately preceding the STOP condition
signifies the end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.block_read_pec">
<code class="descname">block_read_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.block_read_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block_read with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.block_write">
<code class="descname">block_write</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteList</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.block_write" title="Permalink to this definition">¶</a></dt>
<dd><p>The Block Write begins with a slave address and a write condition. After the command code the host
issues a byte count which describes how many more bytes will follow in the message. If a slave has 20
bytes to send, the byte count field will have the value 20 (14h), followed by the 20 bytes of data. The byte
count does not include the PEC byte. The byte count may not be 0. A Block Read or Write is allowed to
transfer a maximum of 32 data bytes.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.block_write_pec">
<code class="descname">block_write_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteList</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.block_write_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block_write with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.check_size">
<code class="descname">check_size</code><span class="sig-paren">(</span><em>data</em>, <em>bits</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.check_size" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure data fits within word of length  &#8220;bits&#8221;</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_pic.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.close" title="Permalink to this definition">¶</a></dt>
<dd><p>close the underlying (serial) interface</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.high_byte">
<code class="descname">high_byte</code><span class="sig-paren">(</span><em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.high_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Select upper byte from 16-bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.low_byte">
<code class="descname">low_byte</code><span class="sig-paren">(</span><em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.low_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Select lower byte from 16-bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.pec">
<code class="descname">pec</code><span class="sig-paren">(</span><em>byteList</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.pec" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference external" href="http://smbus.org/specs/smbus20.pdf">http://smbus.org/specs/smbus20.pdf</a>
Each bus transaction requires a Packet Error Code (PEC) calculation by both the transmitter and receiver
within each packet. The PEC uses an 8-bit cyclic redundancy check (CRC-8) of each read or write bus
transaction to calculate a Packet Error Code (PEC). The PEC may be calculated in any way that conforms
to a CRC-8 represented by the polynomial, C(x) = x8 + x2 + x1 + 1 and must be calculated in the order of
the bits as received.
Calculating the PEC for transmission or reception is implemented in a method chosen by the device
manufacturer. It is possible to perform the check with low-cost hardware or firmware algorithm that could
process the message bit-by-bit or with a byte-wise look-up table. The SMBus web page provides some
example CRC-8 methods.
The PEC is appended to the message as dictated by the protocols in section 5.5. The PEC calculation
includes all bytes in the transmission, including address, command and data. The PEC calculation does not
include ACK, NACK, START, STOP nor Repeated START bits. This means that the PEC is computed
over the entire message from the first START condition.
Whether a device implements packet error checking may be determined by the specification revision code
that is present in the SpecificationInfo() command for a Smart Battery, Smart Battery Charger or Smart
Battery Selector. See these individual specifications for exact revision coding identities. It may also be
discovered in the UDID, defined in section 5.6.1, for other devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.process_call">
<code class="descname">process_call</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.process_call" title="Permalink to this definition">¶</a></dt>
<dd><p>The process call is so named because a command sends data and waits for the slave to return a value
dependent on that data. The protocol is simply a Write Word followed by a Read Word without the Read-
Word command field and the Write-Word STOP bit.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.process_call_pec">
<code class="descname">process_call_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.process_call_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>process_call with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.quick_command_rd">
<code class="descname">quick_command_rd</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.quick_command_rd" title="Permalink to this definition">¶</a></dt>
<dd><p>Here, part of the slave address denotes the command – the R/W# bit. The R/W# bit may be used to simply
turn a device function on or off, or enable/disable a low-power standby mode. There is no data sent or
received.
The quick command implementation is good for very small devices that have limited support for the
SMBus specification. It also limits data on the bus for simple devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.quick_command_wr">
<code class="descname">quick_command_wr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.quick_command_wr" title="Permalink to this definition">¶</a></dt>
<dd><p>Here, part of the slave address denotes the command – the R/W# bit. The R/W# bit may be used to simply
turn a device function on or off, or enable/disable a low-power standby mode. There is no data sent or
received.
The quick command implementation is good for very small devices that have limited support for the
SMBus specification. It also limits data on the bus for simple devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.read_addr">
<code class="descname">read_addr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.read_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>compute 8-bit read address from 7-bit address</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.read_byte">
<code class="descname">read_byte</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.read_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Reading data is slightly more complicated than writing data. First the host must write a command to the
slave device. Then it must follow that command with a repeated START condition to denote a read from
that device’s address. The slave then returns one byte of data.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.read_byte_list">
<code class="descname">read_byte_list</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.read_byte_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_byte results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.read_byte_list_pec">
<code class="descname">read_byte_list_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.read_byte_list_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_byte_pec results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.read_byte_pec">
<code class="descname">read_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.read_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>read_byte with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.read_word">
<code class="descname">read_word</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_pic.read_word"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.read_word" title="Permalink to this definition">¶</a></dt>
<dd><p>faster way to do an smbus read word</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.read_word_list">
<code class="descname">read_word_list</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.read_word_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_word results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.read_word_list_pec">
<code class="descname">read_word_list_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.read_word_list_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_word_pec results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.read_word_pec">
<code class="descname">read_word_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.read_word_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>read_word with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.receive_byte">
<code class="descname">receive_byte</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.receive_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>The Receive Byte is similar to a Send Byte, the only difference being the direction of data transfer. A
simple device may have information that the host needs. It can do so with the Receive Byte protocol. The
same device may accept both Send Byte and Receive Byte protocols. A NACK (a ‘1’ in the ACK bit
position) signifies the end of a read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.receive_byte_pec">
<code class="descname">receive_byte_pec</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.receive_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>receive_byte with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.restart">
<code class="descname">restart</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.restart" title="Permalink to this definition">¶</a></dt>
<dd><p>I2C Re-Start  - Falling SDA with SCL high between start and stop condition.
Implement only if restart requires a different action than a normal start in underlying hardware.
Returns True or False to indicate successful arbitration</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.scan">
<code class="descname">scan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.scan" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all devices on bus by checking acknowledge of each address in turn.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.send_byte">
<code class="descname">send_byte</code><span class="sig-paren">(</span><em>addr7</em>, <em>data8</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.send_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple device may recognize its own slave address and accept up to 256 possible encoded commands in
the form of a byte that follows the slave address.
All or parts of the Send Byte may contribute to the command. For example, the highest 7 bits of the
command code might specify an access to a feature, while the least significant bit would tell the device to
turn the feature on or off. Or, a device may set the “volume” of its output based on the value it received
from the Send Byte protocol.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.send_byte_pec">
<code class="descname">send_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>data8</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.send_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>send_byte with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.word">
<code class="descname">word</code><span class="sig-paren">(</span><em>lowByte</em>, <em>highByte</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.word" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 16-bit value from two SMBus bytes</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.write_addr">
<code class="descname">write_addr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.write_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>compute 8-bit write address from 7-bit address</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.write_byte">
<code class="descname">write_byte</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data8</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.write_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>The first byte of a Write Byte access is the command code. The next byte 
is the data to be written. In this example the master asserts the slave device address followed by the write
bit. The device acknowledges and the master delivers the command code. The slave again acknowledges
before the master sends the data byte. The slave acknowledges each byte, and the
entire transaction is finished with a STOP condition.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.write_byte_pec">
<code class="descname">write_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data8</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.write_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>write_byte with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.write_word">
<code class="descname">write_word</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.write_word" title="Permalink to this definition">¶</a></dt>
<dd><p>The first byte of a Write Word access is the command code. The next two bytes
are the data to be written. In this example the master asserts the slave device address followed by the write
bit. The device acknowledges and the master delivers the command code. The slave again acknowledges
before the master sends the data word (low byte first). The slave acknowledges each byte, and the
entire transaction is finished with a STOP condition.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_pic.write_word_pec">
<code class="descname">write_word_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_pic.write_word_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>write_word with additional PEC byte written to slave.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyICe.twoWireInterface.i2c_scpi">
<em class="property">class </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">i2c_scpi</code><span class="sig-paren">(</span><em>visa_interface</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_scpi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#PyICe.twoWireInterface.twoWireInterface" title="PyICe.twoWireInterface.twoWireInterface"><code class="xref py py-class docutils literal"><span class="pre">PyICe.twoWireInterface.twoWireInterface</span></code></a></p>
<p>communication class to simplify talking to atmega32u4 with Steve/Eric SCPI firmware
requires pySerial</p>
<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.alert_response">
<code class="descname">alert_response</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_scpi.alert_response"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.alert_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Another optional signal is an interrupt line for devices that want to trade their ability to master for a pin.
SMBALERT# is a wired-AND signal just as the SMBCLK and SMBDAT signals are. SMBALERT# is
used in conjunction with the SMBus General Call Address. Messages invoked with the SMBus are 2 bytes
long.
A slave-only device can signal the host through SMBALERT# that it wants to talk. The host processes the
interrupt and simultaneously accesses all SMBALERT# devices through the Alert Response Address
(ARA). Only the device(s) which pulled SMBALERT# low will acknowledge the Alert Response Address.
The host performs a modified Receive Byte operation. The 7 bit device address provided by the slave
transmit device is placed in the 7 most significant bits of the byte. The eighth bit can be a zero or one.</p>
<p>Returns 7 bit address of responding device.
Returns None if no response to ARA</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.alert_response_pec">
<code class="descname">alert_response_pec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_scpi.alert_response_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.alert_response_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Alert Response Query to SMBALERT# interrupt with Packet Error Check
Returns 7 bit address of responding device.
Returns None if no response to ARA</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.block_process_call">
<code class="descname">block_process_call</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteListWrite</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.block_process_call" title="Permalink to this definition">¶</a></dt>
<dd><p>The block write-block read process call is a two-part message. The call begins with a slave address and a
write condition. After the command code the host issues a write byte count (M) that describes how many
more bytes will be written in the first part of the message. If a master has 6 bytes to send, the byte count
field will have the value 6 (0000 0110b), followed by the 6 bytes of data. The write byte count (M) cannot
be zero.
The second part of the message is a block of read data beginning with a repeated start condition followed
by the slave address and a Read bit. The next byte is the read byte count (N), which may differ from the
write byte count (M). The read byte count (N) cannot be zero.
The combined data payload must not exceed 32 bytes. The byte length restrictions of this process call are
summarized as follows:
• M ≥ 1 byte
• N ≥ 1 byte
• M + N ≤ 32 bytes
The read byte count does not include the PEC byte. The PEC is computed on the total message beginning
with the first slave address and using the normal PEC computational rules. It is highly recommended that a
PEC byte be used with the Block Write-Block Read Process Call.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.block_process_call_pec">
<code class="descname">block_process_call_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteListWrite</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.block_process_call_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block write-block read process call with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.block_read">
<code class="descname">block_read</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.block_read" title="Permalink to this definition">¶</a></dt>
<dd><p>A Block Read differs from a block write in that the repeated START condition exists to satisfy the
requirement for a change in the transfer direction. A NACK immediately preceding the STOP condition
signifies the end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.block_read_pec">
<code class="descname">block_read_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.block_read_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block_read with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.block_write">
<code class="descname">block_write</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteList</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.block_write" title="Permalink to this definition">¶</a></dt>
<dd><p>The Block Write begins with a slave address and a write condition. After the command code the host
issues a byte count which describes how many more bytes will follow in the message. If a slave has 20
bytes to send, the byte count field will have the value 20 (14h), followed by the 20 bytes of data. The byte
count does not include the PEC byte. The byte count may not be 0. A Block Read or Write is allowed to
transfer a maximum of 32 data bytes.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.block_write_pec">
<code class="descname">block_write_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteList</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.block_write_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block_write with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.check_size">
<code class="descname">check_size</code><span class="sig-paren">(</span><em>data</em>, <em>bits</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.check_size" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure data fits within word of length  &#8220;bits&#8221;</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_scpi.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.close" title="Permalink to this definition">¶</a></dt>
<dd><p>close the underlying (serial) interface</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.high_byte">
<code class="descname">high_byte</code><span class="sig-paren">(</span><em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.high_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Select upper byte from 16-bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.low_byte">
<code class="descname">low_byte</code><span class="sig-paren">(</span><em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.low_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Select lower byte from 16-bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.pec">
<code class="descname">pec</code><span class="sig-paren">(</span><em>byteList</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.pec" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference external" href="http://smbus.org/specs/smbus20.pdf">http://smbus.org/specs/smbus20.pdf</a>
Each bus transaction requires a Packet Error Code (PEC) calculation by both the transmitter and receiver
within each packet. The PEC uses an 8-bit cyclic redundancy check (CRC-8) of each read or write bus
transaction to calculate a Packet Error Code (PEC). The PEC may be calculated in any way that conforms
to a CRC-8 represented by the polynomial, C(x) = x8 + x2 + x1 + 1 and must be calculated in the order of
the bits as received.
Calculating the PEC for transmission or reception is implemented in a method chosen by the device
manufacturer. It is possible to perform the check with low-cost hardware or firmware algorithm that could
process the message bit-by-bit or with a byte-wise look-up table. The SMBus web page provides some
example CRC-8 methods.
The PEC is appended to the message as dictated by the protocols in section 5.5. The PEC calculation
includes all bytes in the transmission, including address, command and data. The PEC calculation does not
include ACK, NACK, START, STOP nor Repeated START bits. This means that the PEC is computed
over the entire message from the first START condition.
Whether a device implements packet error checking may be determined by the specification revision code
that is present in the SpecificationInfo() command for a Smart Battery, Smart Battery Charger or Smart
Battery Selector. See these individual specifications for exact revision coding identities. It may also be
discovered in the UDID, defined in section 5.6.1, for other devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.process_call">
<code class="descname">process_call</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.process_call" title="Permalink to this definition">¶</a></dt>
<dd><p>The process call is so named because a command sends data and waits for the slave to return a value
dependent on that data. The protocol is simply a Write Word followed by a Read Word without the Read-
Word command field and the Write-Word STOP bit.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.process_call_pec">
<code class="descname">process_call_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.process_call_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>process_call with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.quick_command_rd">
<code class="descname">quick_command_rd</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.quick_command_rd" title="Permalink to this definition">¶</a></dt>
<dd><p>Here, part of the slave address denotes the command – the R/W# bit. The R/W# bit may be used to simply
turn a device function on or off, or enable/disable a low-power standby mode. There is no data sent or
received.
The quick command implementation is good for very small devices that have limited support for the
SMBus specification. It also limits data on the bus for simple devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.quick_command_wr">
<code class="descname">quick_command_wr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.quick_command_wr" title="Permalink to this definition">¶</a></dt>
<dd><p>Here, part of the slave address denotes the command – the R/W# bit. The R/W# bit may be used to simply
turn a device function on or off, or enable/disable a low-power standby mode. There is no data sent or
received.
The quick command implementation is good for very small devices that have limited support for the
SMBus specification. It also limits data on the bus for simple devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.read_addr">
<code class="descname">read_addr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.read_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>compute 8-bit read address from 7-bit address</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.read_byte">
<code class="descname">read_byte</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_scpi.read_byte"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.read_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>faster way to do an smbus read byte</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.read_byte_pec">
<code class="descname">read_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_scpi.read_byte_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.read_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>faster way to do an smbus read byte</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.read_word">
<code class="descname">read_word</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_scpi.read_word"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.read_word" title="Permalink to this definition">¶</a></dt>
<dd><p>faster way to do an smbus read word</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.read_word_pec">
<code class="descname">read_word_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_scpi.read_word_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.read_word_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>faster way to do an smbus read word</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.receive_byte">
<code class="descname">receive_byte</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.receive_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>The Receive Byte is similar to a Send Byte, the only difference being the direction of data transfer. A
simple device may have information that the host needs. It can do so with the Receive Byte protocol. The
same device may accept both Send Byte and Receive Byte protocols. A NACK (a ‘1’ in the ACK bit
position) signifies the end of a read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.receive_byte_pec">
<code class="descname">receive_byte_pec</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.receive_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>receive_byte with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.restart">
<code class="descname">restart</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.restart" title="Permalink to this definition">¶</a></dt>
<dd><p>I2C Re-Start  - Falling SDA with SCL high between start and stop condition.
Implement only if restart requires a different action than a normal start in underlying hardware.
Returns True or False to indicate successful arbitration</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.scan">
<code class="descname">scan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.scan" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all devices on bus by checking acknowledge of each address in turn.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.send_byte">
<code class="descname">send_byte</code><span class="sig-paren">(</span><em>addr7</em>, <em>data8</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.send_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple device may recognize its own slave address and accept up to 256 possible encoded commands in
the form of a byte that follows the slave address.
All or parts of the Send Byte may contribute to the command. For example, the highest 7 bits of the
command code might specify an access to a feature, while the least significant bit would tell the device to
turn the feature on or off. Or, a device may set the “volume” of its output based on the value it received
from the Send Byte protocol.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.send_byte_pec">
<code class="descname">send_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>data8</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.send_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>send_byte with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.word">
<code class="descname">word</code><span class="sig-paren">(</span><em>lowByte</em>, <em>highByte</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.word" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 16-bit value from two SMBus bytes</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.write_addr">
<code class="descname">write_addr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.write_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>compute 8-bit write address from 7-bit address</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.write_byte">
<code class="descname">write_byte</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data8</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_scpi.write_byte"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.write_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>faster way to do an smbus write byte</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.write_byte_pec">
<code class="descname">write_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data8</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_scpi.write_byte_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.write_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>faster way to do an smbus write byte</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.write_word">
<code class="descname">write_word</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_scpi.write_word"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.write_word" title="Permalink to this definition">¶</a></dt>
<dd><p>faster way to do an smbus write word</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi.write_word_pec">
<code class="descname">write_word_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_scpi.write_word_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi.write_word_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>faster way to do an smbus write word</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp">
<em class="property">class </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">i2c_scpi_sp</code><span class="sig-paren">(</span><em>visa_interface</em>, <em>portnum</em>, <em>sclpin</em>, <em>sdapin</em>, <em>pullup_en</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_scpi_sp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#PyICe.twoWireInterface.twoWireInterface" title="PyICe.twoWireInterface.twoWireInterface"><code class="xref py py-class docutils literal"><span class="pre">PyICe.twoWireInterface.twoWireInterface</span></code></a></p>
<p>communication class to simplify talking to atmega32u4 softport with Steve/Eric SCPI firmware
requires pySerial</p>
<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.alert_response">
<code class="descname">alert_response</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.alert_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Another optional signal is an interrupt line for devices that want to trade their ability to master for a pin.
SMBALERT# is a wired-AND signal just as the SMBCLK and SMBDAT signals are. SMBALERT# is
used in conjunction with the SMBus General Call Address. Messages invoked with the SMBus are 2 bytes
long.
A slave-only device can signal the host through SMBALERT# that it wants to talk. The host processes the
interrupt and simultaneously accesses all SMBALERT# devices through the Alert Response Address
(ARA). Only the device(s) which pulled SMBALERT# low will acknowledge the Alert Response Address.
The host performs a modified Receive Byte operation. The 7 bit device address provided by the slave
transmit device is placed in the 7 most significant bits of the byte. The eighth bit can be a zero or one.</p>
<p>Returns 7 bit address of responding device.
Returns None if no response to ARA.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.alert_response_pec">
<code class="descname">alert_response_pec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.alert_response_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Alert Response Query to SMBALERT# interrupt with Packet Error Check.
Returns 7 bit address of responding device.
Returns None if no response to ARA.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.block_process_call">
<code class="descname">block_process_call</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteListWrite</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.block_process_call" title="Permalink to this definition">¶</a></dt>
<dd><p>The block write-block read process call is a two-part message. The call begins with a slave address and a
write condition. After the command code the host issues a write byte count (M) that describes how many
more bytes will be written in the first part of the message. If a master has 6 bytes to send, the byte count
field will have the value 6 (0000 0110b), followed by the 6 bytes of data. The write byte count (M) cannot
be zero.
The second part of the message is a block of read data beginning with a repeated start condition followed
by the slave address and a Read bit. The next byte is the read byte count (N), which may differ from the
write byte count (M). The read byte count (N) cannot be zero.
The combined data payload must not exceed 32 bytes. The byte length restrictions of this process call are
summarized as follows:
• M ≥ 1 byte
• N ≥ 1 byte
• M + N ≤ 32 bytes
The read byte count does not include the PEC byte. The PEC is computed on the total message beginning
with the first slave address and using the normal PEC computational rules. It is highly recommended that a
PEC byte be used with the Block Write-Block Read Process Call.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.block_process_call_pec">
<code class="descname">block_process_call_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteListWrite</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.block_process_call_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block write-block read process call with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.block_read">
<code class="descname">block_read</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.block_read" title="Permalink to this definition">¶</a></dt>
<dd><p>A Block Read differs from a block write in that the repeated START condition exists to satisfy the
requirement for a change in the transfer direction. A NACK immediately preceding the STOP condition
signifies the end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.block_read_pec">
<code class="descname">block_read_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.block_read_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block_read with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.block_write">
<code class="descname">block_write</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteList</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.block_write" title="Permalink to this definition">¶</a></dt>
<dd><p>The Block Write begins with a slave address and a write condition. After the command code the host
issues a byte count which describes how many more bytes will follow in the message. If a slave has 20
bytes to send, the byte count field will have the value 20 (14h), followed by the 20 bytes of data. The byte
count does not include the PEC byte. The byte count may not be 0. A Block Read or Write is allowed to
transfer a maximum of 32 data bytes.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.block_write_pec">
<code class="descname">block_write_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteList</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.block_write_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block_write with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.check_size">
<code class="descname">check_size</code><span class="sig-paren">(</span><em>data</em>, <em>bits</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.check_size" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure data fits within word of length  &#8220;bits&#8221;</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_scpi_sp.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.close" title="Permalink to this definition">¶</a></dt>
<dd><p>close the underlying (serial) interface</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.high_byte">
<code class="descname">high_byte</code><span class="sig-paren">(</span><em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.high_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Select upper byte from 16-bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.low_byte">
<code class="descname">low_byte</code><span class="sig-paren">(</span><em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.low_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Select lower byte from 16-bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.pec">
<code class="descname">pec</code><span class="sig-paren">(</span><em>byteList</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.pec" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference external" href="http://smbus.org/specs/smbus20.pdf">http://smbus.org/specs/smbus20.pdf</a>
Each bus transaction requires a Packet Error Code (PEC) calculation by both the transmitter and receiver
within each packet. The PEC uses an 8-bit cyclic redundancy check (CRC-8) of each read or write bus
transaction to calculate a Packet Error Code (PEC). The PEC may be calculated in any way that conforms
to a CRC-8 represented by the polynomial, C(x) = x8 + x2 + x1 + 1 and must be calculated in the order of
the bits as received.
Calculating the PEC for transmission or reception is implemented in a method chosen by the device
manufacturer. It is possible to perform the check with low-cost hardware or firmware algorithm that could
process the message bit-by-bit or with a byte-wise look-up table. The SMBus web page provides some
example CRC-8 methods.
The PEC is appended to the message as dictated by the protocols in section 5.5. The PEC calculation
includes all bytes in the transmission, including address, command and data. The PEC calculation does not
include ACK, NACK, START, STOP nor Repeated START bits. This means that the PEC is computed
over the entire message from the first START condition.
Whether a device implements packet error checking may be determined by the specification revision code
that is present in the SpecificationInfo() command for a Smart Battery, Smart Battery Charger or Smart
Battery Selector. See these individual specifications for exact revision coding identities. It may also be
discovered in the UDID, defined in section 5.6.1, for other devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.process_call">
<code class="descname">process_call</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.process_call" title="Permalink to this definition">¶</a></dt>
<dd><p>The process call is so named because a command sends data and waits for the slave to return a value
dependent on that data. The protocol is simply a Write Word followed by a Read Word without the Read-
Word command field and the Write-Word STOP bit.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.process_call_pec">
<code class="descname">process_call_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.process_call_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>process_call with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.quick_command_rd">
<code class="descname">quick_command_rd</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.quick_command_rd" title="Permalink to this definition">¶</a></dt>
<dd><p>Here, part of the slave address denotes the command – the R/W# bit. The R/W# bit may be used to simply
turn a device function on or off, or enable/disable a low-power standby mode. There is no data sent or
received.
The quick command implementation is good for very small devices that have limited support for the
SMBus specification. It also limits data on the bus for simple devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.quick_command_wr">
<code class="descname">quick_command_wr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.quick_command_wr" title="Permalink to this definition">¶</a></dt>
<dd><p>Here, part of the slave address denotes the command – the R/W# bit. The R/W# bit may be used to simply
turn a device function on or off, or enable/disable a low-power standby mode. There is no data sent or
received.
The quick command implementation is good for very small devices that have limited support for the
SMBus specification. It also limits data on the bus for simple devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.read_addr">
<code class="descname">read_addr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.read_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>compute 8-bit read address from 7-bit address</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.read_byte">
<code class="descname">read_byte</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_scpi_sp.read_byte"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.read_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>faster way to do an smbus read byte</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.read_byte_list">
<code class="descname">read_byte_list</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.read_byte_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_byte results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.read_byte_list_pec">
<code class="descname">read_byte_list_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.read_byte_list_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_byte_pec results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.read_byte_pec">
<code class="descname">read_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.read_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>read_byte with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.read_word">
<code class="descname">read_word</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_scpi_sp.read_word"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.read_word" title="Permalink to this definition">¶</a></dt>
<dd><p>faster way to do an smbus read word</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.read_word_list">
<code class="descname">read_word_list</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.read_word_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_word results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.read_word_list_pec">
<code class="descname">read_word_list_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.read_word_list_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_word_pec results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.read_word_pec">
<code class="descname">read_word_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.read_word_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>read_word with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.receive_byte">
<code class="descname">receive_byte</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.receive_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>The Receive Byte is similar to a Send Byte, the only difference being the direction of data transfer. A
simple device may have information that the host needs. It can do so with the Receive Byte protocol. The
same device may accept both Send Byte and Receive Byte protocols. A NACK (a ‘1’ in the ACK bit
position) signifies the end of a read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.receive_byte_pec">
<code class="descname">receive_byte_pec</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.receive_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>receive_byte with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.restart">
<code class="descname">restart</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.restart" title="Permalink to this definition">¶</a></dt>
<dd><p>I2C Re-Start  - Falling SDA with SCL high between start and stop condition.
Implement only if restart requires a different action than a normal start in underlying hardware.
Returns True or False to indicate successful arbitration</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.scan">
<code class="descname">scan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.scan" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all devices on bus by checking acknowledge of each address in turn.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.send_byte">
<code class="descname">send_byte</code><span class="sig-paren">(</span><em>addr7</em>, <em>data8</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.send_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple device may recognize its own slave address and accept up to 256 possible encoded commands in
the form of a byte that follows the slave address.
All or parts of the Send Byte may contribute to the command. For example, the highest 7 bits of the
command code might specify an access to a feature, while the least significant bit would tell the device to
turn the feature on or off. Or, a device may set the “volume” of its output based on the value it received
from the Send Byte protocol.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.send_byte_pec">
<code class="descname">send_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>data8</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.send_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>send_byte with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.word">
<code class="descname">word</code><span class="sig-paren">(</span><em>lowByte</em>, <em>highByte</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.word" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 16-bit value from two SMBus bytes</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.write_addr">
<code class="descname">write_addr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.write_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>compute 8-bit write address from 7-bit address</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.write_byte">
<code class="descname">write_byte</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data8</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_scpi_sp.write_byte"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.write_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>faster way to do an smbus write byte</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.write_byte_pec">
<code class="descname">write_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data8</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.write_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>write_byte with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.write_word">
<code class="descname">write_word</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#i2c_scpi_sp.write_word"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.write_word" title="Permalink to this definition">¶</a></dt>
<dd><p>faster way to do an smbus write word</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.i2c_scpi_sp.write_word_pec">
<code class="descname">write_word_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="headerlink" href="#PyICe.twoWireInterface.i2c_scpi_sp.write_word_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>write_word with additional PEC byte written to slave.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyICe.twoWireInterface.twoWireInterface">
<em class="property">class </em><code class="descclassname">PyICe.twoWireInterface.</code><code class="descname">twoWireInterface</code><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>this is the master i2c class, all other i2c adapters inherit from this</p>
<p>All SMBus Protocols are implemented generically with I2C Primitives
Board specific subclasses should overload as necessary for increased performance
addr7 is the 7-bit chip address  The 8-bit read/write addresses are computed locally</p>
<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.alert_response">
<code class="descname">alert_response</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.alert_response"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.alert_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Another optional signal is an interrupt line for devices that want to trade their ability to master for a pin.
SMBALERT# is a wired-AND signal just as the SMBCLK and SMBDAT signals are. SMBALERT# is
used in conjunction with the SMBus General Call Address. Messages invoked with the SMBus are 2 bytes
long.
A slave-only device can signal the host through SMBALERT# that it wants to talk. The host processes the
interrupt and simultaneously accesses all SMBALERT# devices through the Alert Response Address
(ARA). Only the device(s) which pulled SMBALERT# low will acknowledge the Alert Response Address.
The host performs a modified Receive Byte operation. The 7 bit device address provided by the slave
transmit device is placed in the 7 most significant bits of the byte. The eighth bit can be a zero or one.</p>
<p>Returns 7 bit address of responding device.
Returns None if no response to ARA.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.alert_response_pec">
<code class="descname">alert_response_pec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.alert_response_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.alert_response_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Alert Response Query to SMBALERT# interrupt with Packet Error Check.
Returns 7 bit address of responding device.
Returns None if no response to ARA.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.block_process_call">
<code class="descname">block_process_call</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteListWrite</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.block_process_call"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.block_process_call" title="Permalink to this definition">¶</a></dt>
<dd><p>The block write-block read process call is a two-part message. The call begins with a slave address and a
write condition. After the command code the host issues a write byte count (M) that describes how many
more bytes will be written in the first part of the message. If a master has 6 bytes to send, the byte count
field will have the value 6 (0000 0110b), followed by the 6 bytes of data. The write byte count (M) cannot
be zero.
The second part of the message is a block of read data beginning with a repeated start condition followed
by the slave address and a Read bit. The next byte is the read byte count (N), which may differ from the
write byte count (M). The read byte count (N) cannot be zero.
The combined data payload must not exceed 32 bytes. The byte length restrictions of this process call are
summarized as follows:
• M ≥ 1 byte
• N ≥ 1 byte
• M + N ≤ 32 bytes
The read byte count does not include the PEC byte. The PEC is computed on the total message beginning
with the first slave address and using the normal PEC computational rules. It is highly recommended that a
PEC byte be used with the Block Write-Block Read Process Call.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.block_process_call_pec">
<code class="descname">block_process_call_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteListWrite</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.block_process_call_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.block_process_call_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block write-block read process call with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.block_read">
<code class="descname">block_read</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.block_read"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.block_read" title="Permalink to this definition">¶</a></dt>
<dd><p>A Block Read differs from a block write in that the repeated START condition exists to satisfy the
requirement for a change in the transfer direction. A NACK immediately preceding the STOP condition
signifies the end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.block_read_pec">
<code class="descname">block_read_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.block_read_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.block_read_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block_read with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.block_write">
<code class="descname">block_write</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteList</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.block_write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.block_write" title="Permalink to this definition">¶</a></dt>
<dd><p>The Block Write begins with a slave address and a write condition. After the command code the host
issues a byte count which describes how many more bytes will follow in the message. If a slave has 20
bytes to send, the byte count field will have the value 20 (14h), followed by the 20 bytes of data. The byte
count does not include the PEC byte. The byte count may not be 0. A Block Read or Write is allowed to
transfer a maximum of 32 data bytes.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.block_write_pec">
<code class="descname">block_write_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>dataByteList</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.block_write_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.block_write_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>block_write with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.check_size">
<code class="descname">check_size</code><span class="sig-paren">(</span><em>data</em>, <em>bits</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.check_size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.check_size" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure data fits within word of length  &#8220;bits&#8221;</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.close" title="Permalink to this definition">¶</a></dt>
<dd><p>close the underlying (serial) interface</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.high_byte">
<code class="descname">high_byte</code><span class="sig-paren">(</span><em>data16</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.high_byte"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.high_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Select upper byte from 16-bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.low_byte">
<code class="descname">low_byte</code><span class="sig-paren">(</span><em>data16</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.low_byte"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.low_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Select lower byte from 16-bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.pec">
<code class="descname">pec</code><span class="sig-paren">(</span><em>byteList</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.pec" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference external" href="http://smbus.org/specs/smbus20.pdf">http://smbus.org/specs/smbus20.pdf</a>
Each bus transaction requires a Packet Error Code (PEC) calculation by both the transmitter and receiver
within each packet. The PEC uses an 8-bit cyclic redundancy check (CRC-8) of each read or write bus
transaction to calculate a Packet Error Code (PEC). The PEC may be calculated in any way that conforms
to a CRC-8 represented by the polynomial, C(x) = x8 + x2 + x1 + 1 and must be calculated in the order of
the bits as received.
Calculating the PEC for transmission or reception is implemented in a method chosen by the device
manufacturer. It is possible to perform the check with low-cost hardware or firmware algorithm that could
process the message bit-by-bit or with a byte-wise look-up table. The SMBus web page provides some
example CRC-8 methods.
The PEC is appended to the message as dictated by the protocols in section 5.5. The PEC calculation
includes all bytes in the transmission, including address, command and data. The PEC calculation does not
include ACK, NACK, START, STOP nor Repeated START bits. This means that the PEC is computed
over the entire message from the first START condition.
Whether a device implements packet error checking may be determined by the specification revision code
that is present in the SpecificationInfo() command for a Smart Battery, Smart Battery Charger or Smart
Battery Selector. See these individual specifications for exact revision coding identities. It may also be
discovered in the UDID, defined in section 5.6.1, for other devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.process_call">
<code class="descname">process_call</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.process_call"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.process_call" title="Permalink to this definition">¶</a></dt>
<dd><p>The process call is so named because a command sends data and waits for the slave to return a value
dependent on that data. The protocol is simply a Write Word followed by a Read Word without the Read-
Word command field and the Write-Word STOP bit.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.process_call_pec">
<code class="descname">process_call_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.process_call_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.process_call_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>process_call with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.quick_command_rd">
<code class="descname">quick_command_rd</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.quick_command_rd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.quick_command_rd" title="Permalink to this definition">¶</a></dt>
<dd><p>Here, part of the slave address denotes the command – the R/W# bit. The R/W# bit may be used to simply
turn a device function on or off, or enable/disable a low-power standby mode. There is no data sent or
received.
The quick command implementation is good for very small devices that have limited support for the
SMBus specification. It also limits data on the bus for simple devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.quick_command_wr">
<code class="descname">quick_command_wr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.quick_command_wr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.quick_command_wr" title="Permalink to this definition">¶</a></dt>
<dd><p>Here, part of the slave address denotes the command – the R/W# bit. The R/W# bit may be used to simply
turn a device function on or off, or enable/disable a low-power standby mode. There is no data sent or
received.
The quick command implementation is good for very small devices that have limited support for the
SMBus specification. It also limits data on the bus for simple devices.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.read_ack">
<code class="descname">read_ack</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.read_ack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.read_ack" title="Permalink to this definition">¶</a></dt>
<dd><p>Read 8 bits from slave transmitter  and assert SDA during 9th acknowledge clock.  Returns 8 bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.read_addr">
<code class="descname">read_addr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.read_addr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.read_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>compute 8-bit read address from 7-bit address</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.read_byte">
<code class="descname">read_byte</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.read_byte"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.read_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Reading data is slightly more complicated than writing data. First the host must write a command to the
slave device. Then it must follow that command with a repeated START condition to denote a read from
that device’s address. The slave then returns one byte of data.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.read_byte_list">
<code class="descname">read_byte_list</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.read_byte_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.read_byte_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_byte results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.read_byte_list_pec">
<code class="descname">read_byte_list_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.read_byte_list_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.read_byte_list_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_byte_pec results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.read_byte_pec">
<code class="descname">read_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.read_byte_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.read_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>read_byte with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.read_nack">
<code class="descname">read_nack</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.read_nack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.read_nack" title="Permalink to this definition">¶</a></dt>
<dd><p>Read 8 bits from slave transmitter  and release SDA during 9th acknowledge clock to request end of transmission.  Returns 8 bit data</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.read_word">
<code class="descname">read_word</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.read_word"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.read_word" title="Permalink to this definition">¶</a></dt>
<dd><p>Reading data is slightly more complicated than writing data. First the host must write a command to the
slave device. Then it must follow that command with a repeated START condition to denote a read from
that device’s address. The slave then returns two bytes of data.
Note that there is no STOP condition before the repeated START condition, and that a NACK signifies the
end of the read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.read_word_list">
<code class="descname">read_word_list</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.read_word_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.read_word_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_word results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.read_word_list_pec">
<code class="descname">read_word_list_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>cc_list</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.read_word_list_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.read_word_list_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dictionary of read_word_pec results.  
Reads each commandCode of cc_list in turn at chip address addr7
Overload this method to improve communication speed when the instrument supports it.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.read_word_pec">
<code class="descname">read_word_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.read_word_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.read_word_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>read_word with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.receive_byte">
<code class="descname">receive_byte</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.receive_byte"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.receive_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>The Receive Byte is similar to a Send Byte, the only difference being the direction of data transfer. A
simple device may have information that the host needs. It can do so with the Receive Byte protocol. The
same device may accept both Send Byte and Receive Byte protocols. A NACK (a ‘1’ in the ACK bit
position) signifies the end of a read transfer.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.receive_byte_pec">
<code class="descname">receive_byte_pec</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.receive_byte_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.receive_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>receive_byte with additional PEC byte read from slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.restart">
<code class="descname">restart</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.restart"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.restart" title="Permalink to this definition">¶</a></dt>
<dd><p>I2C Re-Start  - Falling SDA with SCL high between start and stop condition.
Implement only if restart requires a different action than a normal start in underlying hardware.
Returns True or False to indicate successful arbitration</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.resync_communication">
<code class="descname">resync_communication</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.resync_communication"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.resync_communication" title="Permalink to this definition">¶</a></dt>
<dd><p>attempt to correct problems caused by dropped/duplicate characters in serial buffer, etc.
Don&#8217;t do anything here.  Method must be overloaded to implement hardware-specific recovery procedure.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.scan">
<code class="descname">scan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.scan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.scan" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all devices on bus by checking acknowledge of each address in turn.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.send_byte">
<code class="descname">send_byte</code><span class="sig-paren">(</span><em>addr7</em>, <em>data8</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.send_byte"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.send_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple device may recognize its own slave address and accept up to 256 possible encoded commands in
the form of a byte that follows the slave address.
All or parts of the Send Byte may contribute to the command. For example, the highest 7 bits of the
command code might specify an access to a feature, while the least significant bit would tell the device to
turn the feature on or off. Or, a device may set the “volume” of its output based on the value it received
from the Send Byte protocol.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.send_byte_pec">
<code class="descname">send_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>data8</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.send_byte_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.send_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>send_byte with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.start">
<code class="descname">start</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.start"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.start" title="Permalink to this definition">¶</a></dt>
<dd><p>I2C Start  - Falling SDA with SCL high.  Returns True or False to indicate successful arbitration</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.stop">
<code class="descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.stop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>I2C Stop  - Rising SDA with SCL high.  Returns True or False to indicate successful arbitration</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.word">
<code class="descname">word</code><span class="sig-paren">(</span><em>lowByte</em>, <em>highByte</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.word"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.word" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 16-bit value from two SMBus bytes</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>data8</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Transmit 8 bits plus 9th acknowledge clock.  Returns True or False to indicate slave acknowledge</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.write_addr">
<code class="descname">write_addr</code><span class="sig-paren">(</span><em>addr7</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.write_addr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.write_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>compute 8-bit write address from 7-bit address</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.write_byte">
<code class="descname">write_byte</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data8</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.write_byte"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.write_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>The first byte of a Write Byte access is the command code. The next byte 
is the data to be written. In this example the master asserts the slave device address followed by the write
bit. The device acknowledges and the master delivers the command code. The slave again acknowledges
before the master sends the data byte. The slave acknowledges each byte, and the
entire transaction is finished with a STOP condition.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.write_byte_pec">
<code class="descname">write_byte_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data8</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.write_byte_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.write_byte_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>write_byte with additional PEC byte written to slave.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.write_word">
<code class="descname">write_word</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.write_word"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.write_word" title="Permalink to this definition">¶</a></dt>
<dd><p>The first byte of a Write Word access is the command code. The next two bytes
are the data to be written. In this example the master asserts the slave device address followed by the write
bit. The device acknowledges and the master delivers the command code. The slave again acknowledges
before the master sends the data word (low byte first). The slave acknowledges each byte, and the
entire transaction is finished with a STOP condition.</p>
</dd></dl>

<dl class="method">
<dt id="PyICe.twoWireInterface.twoWireInterface.write_word_pec">
<code class="descname">write_word_pec</code><span class="sig-paren">(</span><em>addr7</em>, <em>commandCode</em>, <em>data16</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/PyICe/twoWireInterface.html#twoWireInterface.write_word_pec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyICe.twoWireInterface.twoWireInterface.write_word_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>write_word with additional PEC byte written to slave.</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../PyICe.html">
              <img class="logo" src="../_static/tssop.png" alt="Logo"/>
            </a></p>
<h3><a href="../PyICe.html">Table Of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="PyICe.lab_instruments.html">PyICe.lab_instruments</a></li>
<li class="toctree-l1"><a class="reference internal" href="PyICe.lab_core.html">PyICe.lab_core</a></li>
<li class="toctree-l1"><a class="reference internal" href="PyICe.lab_utils.html">PyICe.lab_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="PyICe.LTC_plot.html">PyICe.LTC_plot</a></li>
<li class="toctree-l1"><a class="reference internal" href="PyICe.lab_gui.html">PyICe.lab_gui</a></li>
<li class="toctree-l1"><a class="reference internal" href="PyICe.lab_interfaces.html">PyICe.lab_interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="PyICe.twi_instrument.html">PyICe.twi_instrument</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">PyICe.twoWireInterface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#smbus-interface-hardware-drivers">SMBus Interface Hardware Drivers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="PyICe.spi_instrument.html">PyICe.spi_instrument</a></li>
<li class="toctree-l1"><a class="reference internal" href="PyICe.spi_interface.html">PyICe.spi_interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="PyICe.visa_wrappers.html">PyICe.visa_wrappers</a></li>
<li class="toctree-l1"><a class="reference internal" href="PyICe.xml_registers.html">PyICe.xml_registers</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../PyICe.html">Documentation overview</a><ul>
      <li>Previous: <a href="PyICe.twi_instrument.html" title="previous chapter">PyICe.twi_instrument</a></li>
      <li>Next: <a href="PyICe.spi_instrument.html" title="next chapter">PyICe.spi_instrument</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/_autosummary/PyICe.twoWireInterface.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Linear Technology Corporation.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.6</a>
      
      |
      <a href="../_sources/_autosummary/PyICe.twoWireInterface.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>